<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2022/03/26/hello-world22/"/>
      <url>/blog/2022/03/26/hello-world22/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三个好用的网站，及学编程的技巧</title>
      <link href="/blog/2020/03/11/san-ge-hao-yong-de-wang-zhan-ji-xue-bian-cheng-de-ji-qiao/"/>
      <url>/blog/2020/03/11/san-ge-hao-yong-de-wang-zhan-ji-xue-bian-cheng-de-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>在我看来，最好的工具还是谷歌，没有它搜不到的，基本上你遇到的技术问题， 90% 的它都能解决。，经常流行着这句话『外事问谷歌，内事问百度，房事问天涯，性事问猫扑』，而如今的天涯和猫扑已经失去当前的风光。</p><p>《<a href="https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&mid=2247488857&idx=1&sn=997c6d0c8a38c060042125838f556e31&chksm=e8fe8950df890046861d12daf98994694cf629ae138f30f1a3dee27045cf1651283afe8e2da5&scene=21#wechat_redirect">使用IDEA追踪bug</a>》</p><p>如果你是我公众号的老读者，一定还记得我之前写的关于谷歌搜索引擎语法的入门文章，见《<a href="http://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&mid=2247483811&idx=1&sn=e10459acae8b63d27c890dacc1a8da46&chksm=e8fe9daadf8914bcd8c5dd73684d3d508fd0b6290c8d0fac61df2fc18a296f6c675ea50379d3&scene=21#wechat_redirect">Google应该这样玩，你知道这些技巧吗？</a>》。说实话这篇文章确实简单，但是要学会怎么组合，以及怎么选择关键字，还得需要你花一些功夫去研究呢。</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133006.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133006.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>上图只是一个简单的组合来查找一个异常问题，还有很多高级的组合技巧，</p><p>我个人认为，程序员必须会用 Google、Github 以及 StackOverflow 这三个网站，没有为什么，只是希望你的逼格能够高一点点。</p><p>对于各位读者来说，Github 就是一块大大的矿区，里面富含丰富的矿物资源。我相信大多数的读者都是在搜索框输入关键字再敲回车查找，那有没有我们不知道的技巧呢？</p><p>肯定是有的。就比如说快捷键吧，它真的还为我们提供了很多快捷键，来提高我们的搜索速度，怎么查看这些快捷键呢？在 Github 界面，按下 『shift+&#x2F;』，就会弹出快捷键的窗口，里面提供了丰富的快捷键，来提高你的操作速度。</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133024.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133024.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>看到上面的这些快捷键，是不是突然觉得 Github 真的做得很人性化。除了这些Github 也为我们提供了不少搜索语法。</p><ul><li><p>按编程语言搜索， xxx language:java</p></li><li><p>按文件或路径搜索，xxx in:readme</p></li><li><p>按文件大小搜索，xxx size:&gt;100</p></li><li><p>按地域搜索， xxx location:chengdu</p></li><li><p>按是否fork过搜索，xxx fork:true</p></li><li><p>按照拥有者或者组织搜索，xxx user:yrzx404 或者 xxx  org:github</p></li><li><p>按stars数量搜索，xxx stars:&gt;1000</p></li><li><p>按主题搜索，xxx topic:java</p></li><li><p>等等等</p><p>​</p></li></ul><p>这里只罗列了一些我常用的语法，如果你记不住这些语法，Github 同样为我们提供了高级搜索功能，见下图。</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133035.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133035.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>其实它除了搜索外，还给我们提供一个有趣的东西 Trending，如果你用过谷歌指数或者百度指数的话，那么这个东西也就不会陌生了，这个便是展示最近火的开源项目有哪些，在这里你可以看到各种不同开发语言的每天&#x2F;周&#x2F;月的最热门的 Repositories 和 Developers，见下图。</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133048.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133048.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>最后，来聊一下程序员的互答平台 Stack Overflow，这个网站好处在于是以问题为中心，不像知乎、Quora这些以人为中心的问答平台。</p><p>首先，使用它有一个前提『你必须要会一点英语』。</p><p>其次，要精准定位你的问题，其实对于大多数人来说，定位问题很困难，我分享一点小技巧给各位读者，也是我的「三问法」法则。</p><ol><li>什么编程语言？</li><li>干什么事？</li><li>报什么错？</li></ol><p>最后，将你的关键字组合放在搜索框，一般来说，这种方式定位后的答案最准确，见下图。</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133056.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200313133056.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><h2 id="二-。学编程，学会这四步，让你独步天下。"><a href="#二-。学编程，学会这四步，让你独步天下。" class="headerlink" title="二  。学编程，学会这四步，让你独步天下。"></a>二  。学编程，学会这四步，让你独步天下。</h2><p>对于这三个网站，我觉得重点是你必须要掌握 Google 的语法，毕竟全球所有的网站，几乎都会被 Google 所收录。因此，你通过关键字能搜到你想要的任何东西。</p><p>其实，我现在回过头来，想想自己经常逛得那几个网站，都是 Google 帮我找到的。</p><p>对程序员而言，我觉得最重要的问答网站应该就是 <strong>StackOverflow</strong>。因为它上知 Java，下知 MySQL，中间还知道各种算法。几乎你遇到的 90% 的编程问题，都能在它上面找到。</p><p>有了这个网站，学习编程只需 4 步搞定，so easy。</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/xiggsfsfsfaagsf33432.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/xiggsfsfsfaagsf33432.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>有没有觉得编程简单多了？</p><p>上面这个四步法只是能帮助你解决现有的问题，但是真正遇到实际的问题，还得要考验你的真功夫。</p><p>接下来，<strong>说说我为什么对 SO 情有独钟？</strong></p><hr><p><img src="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6mxZMIiaUynrbO5EkTeYAc6iaIzVumlJV1hJstDI6RQDTfpmmZpfCcHGSsCCZCQutavsgpstIfRGbQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload placeholder" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/R5ic1icyNBNd6mxZMIiaUynrbO5EkTeYAc6iaIzVumlJV1hJstDI6RQDTfpmmZpfCcHGSsCCZCQutavsgpstIfRGbQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt="img"></p><p><strong>我之所以喜欢 StackOverflow，在于它没有跟 Quora 和知乎一样，给问答网站加上社交的元素，而是沿用积分机制来鼓励用户回答问题</strong>。因此，你在 StackOverflow 上看不到你获得的 upvote 是由谁发出的。它始终坚持着问答网站的初心，解决「问」与「答」。</p><p>让我特别震惊的是，StackOverflow 社区认为跟<strong>问题</strong>&#x2F;<strong>回答</strong>无关的内容是属于「<strong>噪音</strong>」，包括感谢、打招呼。<strong>他们认为表示感谢的方式就是「upvote + accept answer」</strong>。</p><p>虽然 StackOverflow 上让你享受不到当 superstar 的感觉，但是我还是建议作为程序员的你喜欢上这个网站。</p><p>给 SO 上的新手提个醒，你问了问题，也有别人给你解答了，一定要记得标记正确答案。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>处理机调度与死锁</title>
      <link href="/blog/2020/03/11/chu-li-ji-diao-du-yu-si-suo/"/>
      <url>/blog/2020/03/11/chu-li-ji-diao-du-yu-si-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h1><h2 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h2><h3 id="处理机调度算法的共同目标"><a href="#处理机调度算法的共同目标" class="headerlink" title="处理机调度算法的共同目标"></a>处理机调度算法的共同目标</h3><ul><li><p>资源利用率:CPU的利用率&#x3D;CPU有效工作时间&#x2F;(CPU有效工作时间+CPU空闲等待时间)</p></li><li><p>公平性</p></li><li><p>平衡性</p></li><li><p>策略强制执行</p><h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3></li><li><p>平均周转时间短</p></li><li><p>系统吞吐量高</p></li><li><p>处理机利用率高</p><h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3></li><li><p>响应时间快</p></li><li><p>均衡性</p><h3 id="实时系统目标"><a href="#实时系统目标" class="headerlink" title="实时系统目标"></a>实时系统目标</h3></li><li><p>截止时间的保证</p></li><li><p>可预测性</p><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3></li><li><p>高级调度（作业调度）</p><ul><li>分时系统无需作业调度，因为需要交互</li><li>批处理系统需要作业调度</li></ul></li><li><p>中级调度（和挂起有关）</p></li><li><p>低级调度（进程调度）</p><ul><li><p>进程调度是最基本的调度，任何操作系统都有进程调度。</p></li><li><p>低级调度的三个基本机制</p><ul><li>排队器</li><li>分派器</li><li>上下文切换</li></ul></li><li><p>进程调度方式</p><ul><li>非抢占方式</li><li>抢占方式<ul><li>优先权原则</li><li>短进程优先原则</li><li>时间片原则</li></ul></li></ul></li><li><p>进程调度的任务</p><ul><li>保存处理机的现场信息</li><li>按某种算法选取进程</li><li>把处理器分配给进程</li></ul></li><li><p>进程调度的算法</p><ul><li><p>优先级调度算法</p><ul><li>优先级调度算法的类型<ul><li>非抢占式优先级调度算法<ul><li>等当前进程执行完以后，再执行另一个优先权最高的进程</li><li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li></ul></li><li>抢占式优先级调度算法<ul><li>不等当前进程结束，直接抢处理机</li><li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li></ul></li></ul></li><li>优先级的类型<ul><li>静态优先级<ul><li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li><li>可以参考BIOS系统中设置boot的优先级</li></ul></li><li>动态优先级<ul><li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li></ul></li></ul></li></ul></li><li><p>轮转调度算法</p><ul><li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li><li>进程切换时机<ul><li>时间片未用完，进程完成</li><li>时间片到，进程未完成</li></ul></li><li>时间片大小的确定<ul><li>太小利于短作业，增加系统切换开销</li><li>太长就退化为FCFS算法</li><li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li></ul></li><li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li></ul></li><li><p>多队列调度算法</p></li><li><p>多级反馈队列调度算法</p><ul><li>调度机制<ul><li>设置多个就绪队列</li><li>每个队列都采用FCFS算法</li><li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li></ul></li><li>调度算法的性能<ul><li>对于终端型用户，由于作业小，感觉满意</li><li>对于短批处理作业用户，周转时间也较小</li><li>长批处理作业用户，也能够得到执行</li></ul></li></ul></li><li><p>基于公平原则的调度算法</p><ul><li><p>保证调度算法</p></li><li><p>公平分享调度算法</p><h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3></li></ul></li></ul></li></ul></li><li><p>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。</p><h3 id="作业控制块JCB"><a href="#作业控制块JCB" class="headerlink" title="作业控制块JCB"></a>作业控制块JCB</h3></li><li><p>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。</p><h3 id="作业步"><a href="#作业步" class="headerlink" title="作业步"></a>作业步</h3></li><li><p>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。</p><h3 id="作业运行的三个阶段"><a href="#作业运行的三个阶段" class="headerlink" title="作业运行的三个阶段"></a>作业运行的三个阶段</h3></li><li><p>收容阶段</p></li><li><p>运行阶段</p></li><li><p>完成阶段</p><h3 id="作业运行的三个状态"><a href="#作业运行的三个状态" class="headerlink" title="作业运行的三个状态"></a>作业运行的三个状态</h3></li><li><p>后备状态</p></li><li><p>运行状态</p></li><li><p>完成状态</p><h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3></li><li><p>接纳多少个作业</p></li><li><p>接纳哪些作业</p><h3 id="先来先服务-first–come-first–served，FCFS-调度算法"><a href="#先来先服务-first–come-first–served，FCFS-调度算法" class="headerlink" title="先来先服务(first–come first–served，FCFS)调度算法"></a>先来先服务(first–come first–served，FCFS)调度算法</h3></li><li><p>比较有利于长作业，而不利于短作业。</p></li><li><p>有利于CPU繁忙的作业，而不利于I&#x2F;O繁忙的作业。</p><h3 id="短作业优先-short-job-first，SJF-的调度算法"><a href="#短作业优先-short-job-first，SJF-的调度算法" class="headerlink" title="短作业优先(short job first，SJF)的调度算法"></a>短作业优先(short job first，SJF)的调度算法</h3></li><li><p>优点</p><ul><li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li><li>提高系统的吞吐量；</li></ul></li><li><p>缺点</p><ul><li><p>必须预知作业的运行时间</p></li><li><p>对长作业非常不利，长作业的周转时间会明显地增长</p></li><li><p>在采用SJF算法时，人–机无法实现交互</p></li><li><p>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理</p><h3 id="优先级调度算法-priority–scheduling-algorithm，PSA"><a href="#优先级调度算法-priority–scheduling-algorithm，PSA" class="headerlink" title="优先级调度算法(priority–scheduling algorithm，PSA)"></a>优先级调度算法(priority–scheduling algorithm，PSA)</h3><h3 id="高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN"><a href="#高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN" class="headerlink" title="高响应比优先调度算法(Highest Response Ratio Next,HRRN)"></a>高响应比优先调度算法(Highest Response Ratio Next,HRRN)</h3></li></ul></li><li><p>原理</p><ul><li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li><li>优先权&#x3D;(等待时间+要求服务时间)&#x2F;要求服务时间&#x3D;响应时间&#x2F;要求服务时间&#x3D;1+等待时间&#x2F;要求服务时间</li></ul></li><li><p>特点</p><ul><li><p>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</p></li><li><p>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</p></li><li><p>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机</p><h2 id="实时调度-HRT和SRT任务"><a href="#实时调度-HRT和SRT任务" class="headerlink" title="实时调度(HRT和SRT任务)"></a>实时调度(HRT和SRT任务)</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3></li></ul></li><li><p>提供必要信息</p><ul><li>就绪时间</li><li>开始截止时间和完成截止时间</li><li>处理时间</li><li>资源要求</li><li>优先级</li></ul></li><li><p>系统处理能力强</p><ul><li>∑(Ci&#x2F;Pi)≤1</li><li>N个处理机:∑(Ci&#x2F;Pi)≤N</li></ul></li><li><p>采用抢占式调度机制</p></li><li><p>具有快速切换机制</p><ul><li><p>对中断的快速响应能力</p></li><li><p>快速的任务分派能力</p><h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3></li></ul></li><li><p>非抢占式调度算法</p><ul><li>非抢占式轮转调度算法</li><li>非抢占式优先调度算法</li></ul></li><li><p>抢占式调度算法</p><ul><li><p>基于时钟中断的抢占式优先级调度算法</p></li><li><p>立即抢占的优先级调度算法</p><h3 id="最早截止时间优先EDF-Earliest-Deadline-First-算法"><a href="#最早截止时间优先EDF-Earliest-Deadline-First-算法" class="headerlink" title="最早截止时间优先EDF(Earliest Deadline First)算法"></a>最早截止时间优先EDF(Earliest Deadline First)算法</h3></li></ul></li><li><p>根据任务的开始截至时间来确定任务的优先级</p><ul><li>截至时间越早，优先级越高</li></ul></li><li><p>非抢占式调度方式用于非周期实时任务</p></li><li><p>抢占式调度方式用于周期实时任务</p><h3 id="最低松弛度优先LLF-Least-Laxity-First-算法"><a href="#最低松弛度优先LLF-Least-Laxity-First-算法" class="headerlink" title="最低松弛度优先LLF(Least Laxity First)算法"></a>最低松弛度优先LLF(Least Laxity First)算法</h3></li><li><p>类似EDF</p></li><li><p>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</p></li><li><p>松弛度例子</p><ul><li><p>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms</p><h3 id="优先级倒置-Priority-inversion-problem"><a href="#优先级倒置-Priority-inversion-problem" class="headerlink" title="优先级倒置(Priority inversion problem)"></a>优先级倒置(Priority inversion problem)</h3></li></ul></li><li><p>优先级倒置的形成</p><ul><li>高优先级进程被低优先级进程延迟或阻塞。</li></ul></li><li><p>优先级倒置的解决方法</p><ul><li><p>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</p></li><li><p>实用的:建立在动态优先级继承基础上的</p><h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3></li></ul></li><li><p>可重用性资源</p><ul><li>计算机外设</li></ul></li><li><p>消耗性资源</p><ul><li>数据，消息</li></ul></li><li><p>可抢占性资源</p><ul><li>不引起死锁</li><li>CPU，内存</li></ul></li><li><p>不可抢占性资源</p><ul><li><p>光驱，打印机</p><h3 id="计算机系统中的死锁"><a href="#计算机系统中的死锁" class="headerlink" title="计算机系统中的死锁"></a>计算机系统中的死锁</h3></li></ul></li><li><p>竞争不可抢占性资源引起死锁</p></li><li><p>竞争可消耗资源引起死锁</p></li><li><p>进程推进顺序不当引起死锁</p><h3 id="死锁的定义，必要条件和处理方法"><a href="#死锁的定义，必要条件和处理方法" class="headerlink" title="死锁的定义，必要条件和处理方法"></a>死锁的定义，必要条件和处理方法</h3></li><li><p>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</p></li><li><p>产生死锁的必要条件</p><ul><li>互斥条件</li><li>请求和保存条件</li><li>不可抢占条件</li><li>循环等待条件<ul><li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li></ul></li></ul></li><li><p>处理死锁的方法</p><ul><li>预防死锁<ul><li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li><li>预防死锁的策略<ul><li>破坏”请求和保存”条件<ul><li>第一种协议<ul><li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li><li>优点:简单，易行，安全</li><li>缺点<ul><li>资源被严重浪费，严重地恶化了资源的利用率</li><li>使进程经常会发生饥饿现象</li></ul></li></ul></li><li>第二种协议<ul><li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li></ul></li></ul></li><li>破坏”不可抢占”条件<ul><li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li></ul></li><li>破坏”循环等待”条件<ul><li>对系统所以资源类型进行线性排序，并赋予不同的序号</li><li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li></ul></li></ul></li></ul></li><li>避免死锁<ul><li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li><li>避免死锁的策略<ul><li>系统安全状态<ul><li>安全状态<ul><li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li></ul></li><li>安全状态之例</li><li>由安全状态向不安全状态的转换</li></ul></li><li>利用银行家算法避免死锁<ul><li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li><li>银行家算法中的数据结构<ul><li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]&#x3D;k表示系统中第j类资源数为k个。</li><li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]&#x3D;k表示进程i对j类资源的最大需求数为中k。</li><li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数， Allocation[i,j] &#x3D; k表示进程i已分得j类资源的数目为k个。</li><li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]&#x3D;k 表示进程i 还需要j类资源k个。Need[i,j]&#x3D;Max[i,j] - Allocation[i,j]</li></ul></li><li>银行家算法</li><li>安全性算法</li><li>银行家算法之例</li><li>解题<ul><li>矩阵</li><li>列表</li></ul></li></ul></li></ul></li></ul></li><li>检测死锁<ul><li>死锁的检测与解除<ul><li>死锁的检测<ul><li>资源分配图<ul><li>简化步骤<ul><li>选择一个没有阻塞的进程p</li><li>将p移走，包括它的所有请求边和分配边</li><li>重复步骤1，2，直至不能继续下去</li></ul></li></ul></li><li>死锁定理<ul><li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li></ul></li><li>检测时机<ul><li>当进程等待时检测死锁 （其缺点是系统的开销大）</li><li>定时检测</li><li>系统资源利用率下降时检测死锁</li></ul></li><li>死锁检测中的数据结构</li></ul></li><li>死锁的解除<ul><li>抢占资源</li><li>终止(或撤销)进程</li><li>终止进程的方法<ul><li>终止所有死锁进程</li><li>逐个终止进程<ul><li>代价最小<ul><li>进程的优先级的大小</li><li>进程已执行了多少时间，还需时间</li><li>进程在运行中已经使用资源的多少，还需多少资源</li><li>进程的性质是交互式还是批处理的</li></ul></li></ul></li></ul></li><li>付出代价最小的死锁解除算法<ul><li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li></ul></li></ul></li></ul></li></ul></li><li>解除死锁</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 的使用</title>
      <link href="/blog/2020/03/11/idea-de-shi-yong/"/>
      <url>/blog/2020/03/11/idea-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="日常使用-必备快捷键（★★）"><a href="#日常使用-必备快捷键（★★）" class="headerlink" title="日常使用 必备快捷键（★★）"></a><strong>日常使用 必备快捷键（★★）</strong></h2><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h2><p>快捷键介绍Ctrl + F在当前文件进行文本查找         Ctrl + R在当前文件进行文本替换Shift + Ctrl + F在项目进行文本查找            Shift + Ctrl + R在项目进行文本替换Shift + Shift快速搜索Ctrl + N查找class          Ctrl + Shift + N查找文件                   Ctrl + Shift + Alt + N查找symbol（查找某个方法名）</p><h2 id="跳转切换"><a href="#跳转切换" class="headerlink" title="跳转切换"></a><strong>跳转切换</strong></h2><p>快捷键介绍Ctrl + E最近文件          Ctrl + Tab切换文件          Ctrl + Alt + ←&#x2F;→跳转历史光标所在处               Alt + ←&#x2F;→ 方向键切换子tabCtrl + Ggo to（跳转指定行号）</p><h2 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a><strong>编码相关</strong></h2><p>快捷键介绍Ctrl + W快速选中           (Shift + Ctrl) + Alt + J快速选中同文本         Ctrl + C&#x2F;Ctrl + X&#x2F;Ctrl + D快速复制或剪切多行选中            Tab &#x2F; Shift + TabtabCtrl + Y删除整行滚轮点击变量&#x2F;方法&#x2F;类快速进入变量&#x2F;方法&#x2F;类的定义处            Shift + 点击Tab快速关闭tabCtrl + Z 、Ctrl + Shift + Z后悔药，      撤销&#x2F;取消撤销Ctrl + Shift + enter自动收尾，           代码自动补全Alt + enterIntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同Alt + ↑&#x2F;↓方法快速跳转F2跳转到下一个高亮错误 或 警告位置Alt + Insert代码自动生成，如生成对象的 set &#x2F; get 方法，构造函数，toString() 等             Ctrl + Shift + L 格式化代码                     Shift + F6快速修改方法名、变量名、文件名、类名等Ctrl + F6快速修改方法签名</p><h2 id="代码阅读相关"><a href="#代码阅读相关" class="headerlink" title="代码阅读相关"></a><strong>代码阅读相关</strong></h2><p>快捷键介绍Ctrl + P方法参数提示显示          Ctrl + Shift + i就可以在当前类里再弹出一个窗口出来              Alt + F7可以列出变量在哪些地方被使用了光标在子类接口名，             trl + u跳到父类接口Alt + F1 + 1， esc</p><p>(Shift) + Ctrl + +&#x2F;-代码块折叠Ctrl + Shift + ←&#x2F;→移动窗口分割线                  Ctrl + (Alt) + B跳转方法定义&#x2F;实现                  Ctrl + H类的层级关系Ctrl + F12Show Members 类成员快速显示</p><h2 id="版本管理相关"><a href="#版本管理相关" class="headerlink" title="版本管理相关"></a><strong>版本管理相关</strong></h2><p>快捷键介绍Ctrl + DShow Diff(Shift) + F7（上）下一处修改</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9种设计模式在Spring中的运用，一定要非常熟练！</title>
      <link href="/blog/2020/03/11/9-chong-she-ji-mo-shi-zai-spring-zhong-de-yun-yong-yi-ding-yao-fei-chang-shou-lian/"/>
      <url>/blog/2020/03/11/9-chong-she-ji-mo-shi-zai-spring-zhong-de-yun-yong-yi-ding-yao-fei-chang-shou-lian/</url>
      
        <content type="html"><![CDATA[<p>Spring中涉及的设计模式总结</p><h2 id="1-简单工厂-非23种设计模式中的一种"><a href="#1-简单工厂-非23种设计模式中的一种" class="headerlink" title="1.简单工厂(非23种设计模式中的一种)"></a>1.简单工厂(非23种设计模式中的一种)</h2><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p><h3 id="实质："><a href="#实质：" class="headerlink" title="实质："></a>实质：</h3><p>由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p><strong>bean容器的启动阶段：</strong></p><ul><li><p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。</p></li><li><p>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。</p></li><li><p>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。</p><p>典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</p></li></ul><p><strong>容器中bean的实例化阶段：</strong></p><p>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</p><ul><li><strong>各种的Aware接口</strong>，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。</li><li><strong>BeanPostProcessor接口</strong>，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。</li><li><strong>InitializingBean接口</strong>，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。</li><li><strong>DisposableBean接口</strong>，实现了BeanPostProcessor接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</li></ul><h3 id="设计意义："><a href="#设计意义：" class="headerlink" title="设计意义："></a>设计意义：</h3><p><strong>松耦合。</strong>可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</p><p><strong>bean的额外处理。</strong>通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。<code>[非常重要]</code></p><h2 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h2><h3 id="实现方式：-1"><a href="#实现方式：-1" class="headerlink" title="实现方式："></a>实现方式：</h3><p>FactoryBean接口。</p><h3 id="实现原理：-1"><a href="#实现原理：-1" class="headerlink" title="实现原理："></a>实现原理：</h3><p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>典型的例子有spring与mybatis的结合。</p><p><strong>代码示例：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311153143.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311153143.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><strong>说明：</strong></p><p>我们看上面该bean，因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。</p><h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h2><p>Spring依赖注入Bean实例默认是单例的。</p><p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p><p>分析getSingleton()方法</p><pre class="line-numbers language-none"><code class="language-none">public Object getSingleton(String beanName)&#123;    &#x2F;&#x2F;参数true设置标识允许早期依赖    return getSingleton(beanName,true);&#125;protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;    &#x2F;&#x2F;检查缓存中是否存在实例    Object singletonObject &#x3D; this.singletonObjects.get(beanName);    if (singletonObject &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;        &#x2F;&#x2F;如果为空，则锁定全局变量并进行处理。        synchronized (this.singletonObjects) &#123;            &#x2F;&#x2F;如果此bean正在加载，则不处理            singletonObject &#x3D; this.earlySingletonObjects.get(beanName);            if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;                  &#x2F;&#x2F;当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories                ObjectFactory&lt;?&gt; singletonFactory &#x3D; this.singletonFactories.get(beanName);                if (singletonFactory !&#x3D; null) &#123;                    &#x2F;&#x2F;调用预先设定的getObject方法                    singletonObject &#x3D; singletonFactory.getObject();                    &#x2F;&#x2F;记录在缓存中，earlysingletonObjects和singletonFactories互斥                    this.earlySingletonObjects.put(beanName, singletonObject);                    this.singletonFactories.remove(beanName);                &#125;            &#125;        &#125;    &#125;    return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>getSingleton()过程图</strong></p><p>ps：spring依赖注入时，使用了 双重判断加锁 的单例模式</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311153150.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311153150.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><strong>总结</strong></p><p><strong>单例模式定义：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>spring对单例的实现：</strong>spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</p><h2 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a>4.适配器模式</h2><h3 id="实现方式：-2"><a href="#实现方式：-2" class="headerlink" title="实现方式："></a>实现方式：</h3><p>SpringMVC中的适配器HandlerAdatper。</p><h3 id="实现原理：-2"><a href="#实现原理：-2" class="headerlink" title="实现原理："></a>实现原理：</h3><p>HandlerAdatper根据Handler规则执行不同的Handler。</p><h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h3><p>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</p><p>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</p><h3 id="实现意义："><a href="#实现意义：" class="headerlink" title="实现意义："></a>实现意义：</h3><p>HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。</p><p>因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p><h2 id="5-装饰器模式"><a href="#5-装饰器模式" class="headerlink" title="5.装饰器模式"></a>5.装饰器模式</h2><h3 id="实现方式：-3"><a href="#实现方式：-3" class="headerlink" title="实现方式："></a>实现方式：</h3><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p><h3 id="实质：-1"><a href="#实质：-1" class="headerlink" title="实质："></a>实质：</h3><p>动态地给一个对象添加一些额外的职责。</p><p>就增加功能来说，Decorator模式相比生成子类更为灵活。</p><p>扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486377&idx=2&sn=e88370d32c36b19ac89189341cbaf03b&chksm=ebd63485dca1bd93fd46ce901b8ed5adaa0f1f5db15b8a19902bef66a05bd38ed420e26f7f5e&scene=21#wechat_redirect">设计模式是什么鬼（装饰）</a></p><h2 id="6-代理模式"><a href="#6-代理模式" class="headerlink" title="6.代理模式"></a>6.代理模式</h2><h3 id="实现方式：-4"><a href="#实现方式：-4" class="headerlink" title="实现方式："></a>实现方式：</h3><p>AOP底层，就是动态代理模式的实现。</p><h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><p>在内存中构建的，不需要手动编写代理类</p><h3 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h3><p>需要手工编写代理类，代理类引用被代理对象。</p><h3 id="实现原理：-3"><a href="#实现原理：-3" class="headerlink" title="实现原理："></a>实现原理：</h3><p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。</p><p>织入：把切面应用到目标对象并创建新的代理对象的过程。</p><p>扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247487054&idx=2&sn=489695986c038525e25c017c217b72fb&chksm=ebd63162dca1b874edcaa30680e1da4d3a02c9b0011cb5c60c22d2b9ebea9169022813810bd5&scene=21#wechat_redirect">设计模式是什么鬼（代理）</a></p><h2 id="7-观察者模式"><a href="#7-观察者模式" class="headerlink" title="7.观察者模式"></a>7.观察者模式</h2><h3 id="实现方式：-5"><a href="#实现方式：-5" class="headerlink" title="实现方式："></a>实现方式：</h3><p>spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</p><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><p>事件机制的实现需要三个部分,事件源,事件,事件监听器</p><p>ApplicationEvent抽象类<code>[事件]</code></p><p>继承自jdk的EventObject,所有的事件都需要继承ApplicationEvent,并且通过构造器参数source得到事件源.</p><p>该类的实现类ApplicationContextEvent表示ApplicaitonContext的容器事件.</p><p>代码：</p><pre class="line-numbers language-none"><code class="language-none">public abstract class ApplicationEvent extends EventObject &#123;    private static final long serialVersionUID &#x3D; 7099057708183571937L;    private final long timestamp;    public ApplicationEvent(Object source) &#123;    super(source);    this.timestamp &#x3D; System.currentTimeMillis();    &#125;    public final long getTimestamp() &#123;        return this.timestamp;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ApplicationListener接口<code>[事件监听器]</code></p><p>继承自jdk的EventListener,所有的监听器都要实现这个接口。</p><p>这个接口只有一个onApplicationEvent()方法,该方法接受一个ApplicationEvent或其子类对象作为参数,在方法体中,可以通过不同对Event类的判断来进行相应的处理。</p><p>当事件触发时所有的监听器都会收到消息。</p><p>代码：</p><pre class="line-numbers language-none"><code class="language-none">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;     void onApplicationEvent(E event);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ApplicationContext接口<code>[事件源]</code></p><p>ApplicationContext是spring中的全局容器，翻译过来是”应用上下文”。</p><p>实现了ApplicationEventPublisher接口。</p><h3 id="职责："><a href="#职责：" class="headerlink" title="职责："></a>职责：</h3><p>负责读取bean的配置文档,管理bean的加载,维护bean之间的依赖关系,可以说是负责bean的整个生命周期,再通俗一点就是我们平时所说的IOC容器。</p><p>代码：</p><pre class="line-numbers language-none"><code class="language-none">public interface ApplicationEventPublisher &#123;        void publishEvent(ApplicationEvent event);&#125;   public void publishEvent(ApplicationEvent event) &#123;    Assert.notNull(event, &quot;Event must not be null&quot;);    if (logger.isTraceEnabled()) &#123;         logger.trace(&quot;Publishing event in &quot; + getDisplayName() + &quot;: &quot; + event);    &#125;    getApplicationEventMulticaster().multicastEvent(event);    if (this.parent !&#x3D; null) &#123;    this.parent.publishEvent(event);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ApplicationEventMulticaster抽象类<code>[事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster]</code></p><p>属于事件广播器,它的作用是把Applicationcontext发布的Event广播给所有的监听器.</p><p>代码：</p><pre class="line-numbers language-none"><code class="language-none">public abstract class AbstractApplicationContext extends DefaultResourceLoader    implements ConfigurableApplicationContext, DisposableBean &#123;      private ApplicationEventMulticaster applicationEventMulticaster;      protected void registerListeners() &#123;      &#x2F;&#x2F; Register statically specified listeners first.      for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;      getApplicationEventMulticaster().addApplicationListener(listener);      &#125;      &#x2F;&#x2F; Do not initialize FactoryBeans here: We need to leave all regular beans      &#x2F;&#x2F; uninitialized to let post-processors apply to them!      String[] listenerBeanNames &#x3D; getBeanNamesForType(ApplicationListener.class, true, false);      for (String lisName : listenerBeanNames) &#123;      getApplicationEventMulticaster().addApplicationListenerBean(lisName);      &#125;    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486897&idx=2&sn=927e4dd95695163fa250447ea88e12e8&chksm=ebd6329ddca1bb8bebcd94bc31396ae55c6f28e0ec2057203605aedf9b8cb4a7243c1202e3c5&scene=21#wechat_redirect">设计模式是什么鬼（观察者）</a></p><h2 id="8-策略模式"><a href="#8-策略模式" class="headerlink" title="8.策略模式"></a>8.策略模式</h2><h3 id="实现方式：-6"><a href="#实现方式：-6" class="headerlink" title="实现方式："></a>实现方式：</h3><p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p><h3 id="Resource-接口介绍"><a href="#Resource-接口介绍" class="headerlink" title="Resource 接口介绍"></a>Resource 接口介绍</h3><p>source 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。</p><p>Resource 接口主要提供了如下几个方法:</p><ul><li><p><strong>getInputStream()：</strong>定位并打开资源，返回资源对应的输入流。每次调用都返回新的输入流。调用者必须负责关闭输入流。</p></li><li><p><strong>exists()：</strong>返回 Resource 所指向的资源是否存在。</p></li><li><p><strong>isOpen()：</strong>返回资源文件是否打开，如果资源文件不能多次读取，每次读取结束应该显式关闭，以防止资源泄漏。</p></li><li><p><strong>getDescription()：</strong>返回资源的描述信息，通常用于资源处理出错时输出该信息，通常是全限定文件名或实际 URL。</p></li><li><p><strong>getFile：</strong>返回资源对应的 File 对象。</p></li><li><p><strong>getURL：</strong>返回资源对应的 URL 对象。</p><p>​</p></li></ul><p>最后两个方法通常无须使用，仅在通过简单方式访问无法实现时，Resource 提供传统的资源访问的功能。</p><p>Resource 接口本身没有提供访问任何底层资源的实现逻辑，<strong>针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。</strong></p><p>Spring 为 Resource 接口提供了如下实现类：</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>UrlResource：</strong>访问网络资源的实现类。</li><li><input checked="" disabled="" type="checkbox"> <strong>ClassPathResource：</strong>访问类加载路径里资源的实现类。</li><li><input checked="" disabled="" type="checkbox"> <strong>FileSystemResource：</strong>访问文件系统里资源的实现类。</li><li><input checked="" disabled="" type="checkbox"> <strong>ServletContextResource：</strong>访问相对于 ServletContext 路径里的资源的实现类.</li><li><input checked="" disabled="" type="checkbox"> <strong>InputStreamResource：</strong>访问输入流资源的实现类。</li><li><input checked="" disabled="" type="checkbox"> <strong>ByteArrayResource：</strong>访问字节数组资源的实现类。</li></ul><p>这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</p><p>扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247485903&idx=1&sn=172401bccf663455fd90c55aa957db18&chksm=ebd636e3dca1bff544c671c9f8de3a6e8d40049ab7cea3d750d03ed00ef6e6c4fae376333de1&scene=21#wechat_redirect">设计模式是什么鬼（策略）</a></p><h2 id="9-模版方法模式"><a href="#9-模版方法模式" class="headerlink" title="9.模版方法模式"></a>9.模版方法模式</h2><h3 id="经典模板方法定义："><a href="#经典模板方法定义：" class="headerlink" title="经典模板方法定义："></a>经典模板方法定义：</h3><p>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。</p><p>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。</p><p><strong>所以父类模板方法中有两类方法：</strong></p><p><strong>共同的方法：</strong>所有子类都会用到的代码</p><p><strong>不同的方法：</strong>子类要覆盖的方法，分为两种：</p><ol><li>抽象方法：父类中的是抽象方法，子类必须覆盖</li><li>钩子方法：父类中是一个空方法，子类继承了默认也是空的</li></ol><p>注：为什么叫钩子，子类可以通过这个钩子（方法），控制父类，因为这个钩子实际是父类的方法（空方法）！</p><h3 id="Spring模板方法模式实质："><a href="#Spring模板方法模式实质：" class="headerlink" title="Spring模板方法模式实质："></a>Spring模板方法模式实质：</h3><p>是模板方法模式和回调模式的结合，是Template Method不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。</p><p>推荐：<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247486148&idx=1&sn=601fa38aee0aa27137341ce9a2624fec&chksm=ebd635e8dca1bcfe8da575478244414d13620010cd0d9823f423af8d2457ad1bb65a17d6a940&scene=21#wechat_redirect">设计模式是什么鬼（模板方法）</a></p><h3 id="具体实现：-1"><a href="#具体实现：-1" class="headerlink" title="具体实现："></a>具体实现：</h3><p>JDBC的抽象和对Hibernate的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的Callback接口相结合。</p><p>采用模板方法模式是为了以一种统一而集中的方式来处理资源的获取和释放，以JdbcTempalte为例:</p><pre class="line-numbers language-none"><code class="language-none">public abstract class JdbcTemplate &#123;       public final Object execute（String sql）&#123;          Connection con&#x3D;null;          Statement stmt&#x3D;null;          try&#123;              con&#x3D;getConnection（）;              stmt&#x3D;con.createStatement（）;              Object retValue&#x3D;executeWithStatement（stmt,sql）;              return retValue;          &#125;catch（SQLException e）&#123;               ...          &#125;finally&#123;              closeStatement（stmt）;              releaseConnection（con）;          &#125;      &#125;       protected abstract Object executeWithStatement（Statement   stmt, String sql）;  &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="引入回调原因："><a href="#引入回调原因：" class="headerlink" title="引入回调原因："></a>引入回调原因：</h3><p>JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。</p><p>回调代码</p><pre class="line-numbers language-none"><code class="language-none">public interface StatementCallback&#123;      Object doWithStatement（Statement stmt）;  &#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用回调方法重写JdbcTemplate方法</p><pre class="line-numbers language-none"><code class="language-none">public class JdbcTemplate &#123;      public final Object execute（StatementCallback callback）&#123;          Connection con&#x3D;null;          Statement stmt&#x3D;null;          try&#123;              con&#x3D;getConnection（）;              stmt&#x3D;con.createStatement（）;              Object retValue&#x3D;callback.doWithStatement（stmt）;              return retValue;          &#125;catch（SQLException e）&#123;              ...          &#125;finally&#123;              closeStatement（stmt）;              releaseConnection（con）;          &#125;      &#125;      ...&#x2F;&#x2F;其它方法定义  &#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Jdbc使用方法如下：</p><pre class="line-numbers language-none"><code class="language-none">JdbcTemplate jdbcTemplate&#x3D;...;      final String sql&#x3D;...;      StatementCallback callback&#x3D;new StatementCallback()&#123;      public Object&#x3D;doWithStatement(Statement stmt)&#123;          return ...;      &#125;  &#125;    jdbcTemplate.execute(callback);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为什么JdbcTemplate没有使用继承？"><a href="#为什么JdbcTemplate没有使用继承？" class="headerlink" title="为什么JdbcTemplate没有使用继承？"></a>为什么JdbcTemplate没有使用继承？</h3><p>因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？</p><p>我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？</p><p>那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。</p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三分钟快速实现二叉树的递归遍历</title>
      <link href="/blog/2020/03/11/san-fen-zhong-kuai-su-shi-xian-er-cha-shu-de-di-gui-bian-li/"/>
      <url>/blog/2020/03/11/san-fen-zhong-kuai-su-shi-xian-er-cha-shu-de-di-gui-bian-li/</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图："><a href="#思维导图：" class="headerlink" title="思维导图："></a>思维导图：</h2><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144726.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144726.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><h3 id="什么是树？"><a href="#什么是树？" class="headerlink" title="什么是树？"></a>什么是树？</h3><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/64aaa0.webp" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/64aaa0.webp" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><blockquote><p>树是一种<strong>非线性结构</strong>，有一个直接前驱，但可能有多个直接后继（1：n）；<br>树的定义具有<strong>递归性</strong>，树中还有树；<br>树可以为空，即结节点个数为0；</p></blockquote><p><strong>如图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144820.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144820.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><strong>若干术语：</strong></p><blockquote><p>根：根节点，没有前驱；<br>叶子：终端结点，没有后继；<br>双亲：上层的那个结点，就是直接前驱；<br>孩子：下层结点的子树，就是直接后继；<br>结点：树的数据元素；（上图的结点数为11）<br><strong>结点的度：结点挂接的子树数，有几个直接后继就是几度；</strong><br><strong>树的度：所有结点度中的最大值，Max{各结点的度}，（上图树的度为2）；树的深度（或高度）：所有结点中最大的层数，（上图数的深度为3层）；</strong></p></blockquote><h3 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h3><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144827.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144827.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>二叉树：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144836.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144836.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><code>特征：每个结点**最多只有两个子结点**（不存在度大于2的结点）；</code></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144842.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144842.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>5种形态：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144849.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144849.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>常见的二叉树有两种重要形态，<strong>满二叉树</strong>和<strong>完全二叉树</strong>；</p><blockquote><p><strong>满二叉树：</strong><br>叶子结点全部都在最底层；<br>除叶子结点外，<code>每个结点都有左右两个子节点</code>；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144858.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144858.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><blockquote><p><strong>完全二叉树：</strong><br>叶子结点全都都在最底的两层；<br><code>最后一层只缺少右边的叶子结点，左边一定有叶子结点</code>；<br>除了最后一层，其它层的结点个数均达到最大值；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144905.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144905.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><h3 id="二叉树的遍历："><a href="#二叉树的遍历：" class="headerlink" title="二叉树的遍历："></a>二叉树的遍历：</h3><p>二叉树也是有顺序存储和链式存储，那么其中存储的数据如何读取出来呢？</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144912.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144912.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>于是就有了二叉树的遍历，总共有3种遍历方式：<br><code>先序遍历，中序遍历和后序遍历</code>；<br><strong>先序遍历：</strong></p><blockquote><p>也就是<code>先访问根结点</code>，再左边子结点，最后右边子结点；俗称DLR；</p></blockquote><p>上图中先序遍历访问的结果就是：</p><blockquote><p>A-B-C-D-E-F-G-H；</p></blockquote><p><strong>中序遍历：</strong></p><blockquote><p>也就是先访问左结点，<code>再根结点</code>，最后右结点；俗称LDR；</p></blockquote><p>上图中中序遍历访问的结果是：</p><blockquote><p>B-D-C-E-A-F-H-G;</p></blockquote><p><strong>后序遍历：</strong></p><blockquote><p>先访问左结点，再右结点，<code>最后根结点</code>；俗称LRD；</p></blockquote><p>上图中后序遍历访问的结果是：</p><blockquote><p>D-E-C-B-H-G-F-A；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144920.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144920.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg" alt=" "> </p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p>二叉树递归遍历实现；<br>我们以这个二叉树为例：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144912.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200311144912.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>结点实体类：</p><pre class="line-numbers language-none"><code class="language-none"> 1 package com.java.model; 2 3 public class BinaryTreeNode &#123; 4    &#x2F;&#x2F;树的根结点 5    public char ch; 6    &#x2F;&#x2F;左结点 7    public BinaryTreeNode lchild; 8    &#x2F;&#x2F;右结点 9    public BinaryTreeNode rchild;1011    &#x2F;&#x2F;构造函数12    public BinaryTreeNode(char ch, BinaryTreeNode lchild, BinaryTreeNode rchild) &#123;13        this.ch &#x3D; ch;14        this.lchild &#x3D; lchild;15        this.rchild &#x3D; rchild;16    &#125;17&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法类：</p><pre class="line-numbers language-none"><code class="language-none"> 1  package com.java.dao; 2 3  import com.java.model.BinaryTreeNode; 4 5  &#x2F;&#x2F;二叉树递归遍历 6  public class BTRecursionDao &#123; 7    public void RecursionBiTree(BinaryTreeNode root)&#123; 8        if(root&#x3D;&#x3D;null)&#123; 9            return;10        &#125;11        &#x2F;&#x2F;先序遍历12        System.out.print(root.ch+&quot; &quot;);13        RecursionBiTree(root.lchild);14        RecursionBiTree(root.rchild);1516        &#x2F;**17         * 中序遍历(其实就是把顺序调换一下)18         * RecursionBiTree(root.lchild);19         * System.out.print(root.ch+&quot; &quot;);20         * RecursionBiTree(root.rchild);21         *&#x2F;2223        &#x2F;**24         * 后序遍历25         * RecursionBiTree(root.lchild);26         * RecursionBiTree(root.rchild);27         * System.out.print(root.ch+&quot; &quot;);28         *&#x2F;29    &#125;30&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主函数：</p><pre class="line-numbers language-none"><code class="language-none">1 package com.java.main; 2 3  import com.java.dao.BTRecursionDao; 4  import com.java.model.BinaryTreeNode; 5 6  public class BTRecursionMain &#123; 7    public static void main(String[] args) &#123; 8        BTRecursionDao btRecursionDao&#x3D;new BTRecursionDao(); 9        &#x2F;&#x2F;创建树结点10        BinaryTreeNode node1&#x3D;new BinaryTreeNode(&#39;A&#39;,null,null);11        BinaryTreeNode node2&#x3D;new BinaryTreeNode(&#39;B&#39;,null,null);12        BinaryTreeNode node3&#x3D;new BinaryTreeNode(&#39;C&#39;,null,null);13        BinaryTreeNode node4&#x3D;new BinaryTreeNode(&#39;D&#39;,null,null);14        BinaryTreeNode node5&#x3D;new BinaryTreeNode(&#39;E&#39;,null,null);15        BinaryTreeNode node6&#x3D;new BinaryTreeNode(&#39;F&#39;,null,null);16        BinaryTreeNode node7&#x3D;new BinaryTreeNode(&#39;G&#39;,null,null);17        BinaryTreeNode node8&#x3D;new BinaryTreeNode(&#39;H&#39;,null,null);1819        &#x2F;&#x2F;建立结点间的关系20        node1.lchild&#x3D;node2;  &#x2F;* node1就是A，结点A的左孩子是B(node2)，右孩子是F(node6) *&#x2F;21        node1.rchild&#x3D;node6;22        node2.rchild&#x3D;node3;  &#x2F;* node2就是B，结点B的左孩子为null(初始化就是null，所以不用管)，右孩子是C(node3) *&#x2F;23        node3.lchild&#x3D;node4;24        node3.rchild&#x3D;node5;25        node6.rchild&#x3D;node7;26        node7.lchild&#x3D;node8;2728        &#x2F;&#x2F;递归遍历29        System.out.println(&quot;先序遍历结果:&quot;);30        btRecursionDao.RecursionBiTree(node1);  &#x2F;* 根结点为A *&#x2F;31    &#125;32&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果（这里以先序遍历为例）：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/wwgsgssg.webp" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/wwgsgssg.webp" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>可以自行试试中序遍历和后序遍历；</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O体系从原理到应用，这一篇全说清楚了</title>
      <link href="/blog/2020/03/06/java-io-ti-xi-cong-yuan-li-dao-ying-yong-zhe-yi-pian-quan-shuo-qing-chu-liao/"/>
      <url>/blog/2020/03/06/java-io-ti-xi-cong-yuan-li-dao-ying-yong-zhe-yi-pian-quan-shuo-qing-chu-liao/</url>
      
        <content type="html"><![CDATA[<p>本文介绍操作系统I&#x2F;O工作原理，Java I&#x2F;O设计，基本使用，开源项目中实现高性能I&#x2F;O常见方法和实现，彻底搞懂高性能I&#x2F;O之道</p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="  基础概念"></a><font face="黑体" color=green>  基础概念</font></h1><p>在介绍I&#x2F;O原理之前，先重温几个基础概念：</p><blockquote><ul><li>(1) 操作系统与内核</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308123944.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308123944.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><strong>操作系统</strong>：管理计算机硬件与软件资源的系统软件<strong>内核</strong>：操作系统的核心软件，负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，为应用程序提供对计算机硬件的安全访问服务</p><ul><li><p><strong>2 内核空间和用户空间</strong> </p><p>​</p></li></ul><p>为了避免用户进程直接操作内核，保证内核安全，操作系统将内存寻址空间划分为两部分：<strong>内核空间（Kernel-space）</strong>，供内核程序使用<strong>用户空间（User-space）</strong>，供用户进程使用 为了安全，内核空间和用户空间是隔离的，即使用户的程序崩溃了，内核也不受影响</p><ul><li><p><strong>3 数据流</strong></p><p> <img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308123954.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308123954.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p></li></ul><p>计算机中的数据是基于随着时间变换高低电压信号传输的，这些数据信号连续不断，有着固定的传输方向，类似水管中水的流动，因此抽象数据流(I&#x2F;O流)的概念：<strong>指一组有顺序的、有起点和终点的字节集合</strong>，</p><p>抽象出数据流的作用：<strong>实现程序逻辑与底层硬件解耦</strong>，通过引入数据流作为程序与硬件设备之间的抽象层，面向通用的数据流输入输出接口编程，而不是具体硬件特性，程序和底层硬件可以独立灵活替换和扩展</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308123959.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308123959.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><h1 id="I-x2F-O-工作原理"><a href="#I-x2F-O-工作原理" class="headerlink" title="  I&#x2F;O 工作原理"></a><font face="黑体" color=green>  I&#x2F;O 工作原理</font></h1><h2 id="1-磁盘I-x2F-O"><a href="#1-磁盘I-x2F-O" class="headerlink" title="1 磁盘I&#x2F;O"></a><font face="黑体" color=red>1 磁盘I&#x2F;O</font></h2><p>典型I&#x2F;O读写磁盘工作原理如下：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124004.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124004.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><blockquote><p><strong>tips</strong>: DMA：全称叫直接内存存取（Direct Memory Access），是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。基于 DMA 访问方式，系统主内存与硬件设备的数据传输可以省去CPU 的全程调度</p></blockquote><p>值得注意的是：</p><ul><li>读写操作基于系统调用实现</li><li>读写操作经过用户缓冲区，内核缓冲区，应用进程并不能直接操作磁盘</li><li>应用进程读操作时需阻塞直到读取到数据</li></ul><p><font face="黑体" color=red sice=4>2 网络I&#x2F;O</font></p><p>这里先以最经典的阻塞式I&#x2F;O模型介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124009.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124009.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124016.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124016.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><blockquote><p><strong>tips</strong>:recvfrom，经socket接收数据的函数 </p></blockquote><p>值得注意的是：</p><ul><li>网络I&#x2F;O读写操作经过用户缓冲区，Sokcet缓冲区</li><li>服务端线程在从调用recvfrom开始到它返回有数据报准备好这段时间是阻塞的，recvfrom返回成功后，线程开始处理数据报</li></ul><p>​           <font face="黑体" color=green sice=4>Java I&#x2F;O设计</font></p><p><font face="黑体" color=red sice=2>1 I&#x2F;O分类</font></p><p>Java中对数据流进行具体化和实现，关于Java数据流一般关注以下几个点：</p><ul><li><strong>(1) 流的方向</strong>从外部到程序，称为<strong>输入流</strong>；从程序到外部，称为<strong>输出流</strong></li><li><strong>(2) 流的数据单位</strong>程序以字节作为最小读写数据单元，称为<strong>字节流</strong>，以字符作为最小读写数据单元，称为<strong>字符流</strong></li><li><strong>(3) 流的功能角色</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124024.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124024.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>从&#x2F;向一个特定的IO设备（如磁盘，网络）或者存储对象(如内存数组)读&#x2F;写数据的流，称为<strong>节点流</strong>；</p><p>对一个已有流进行连接和封装，通过封装后的流来实现数据的读&#x2F;写功能，称为<strong>处理流</strong>(或称为过滤流)；</p><p><font face="黑体" color=red sice=2>2 . I&#x2F;O操作接口</font></p><p>java.io包下有一堆I&#x2F;O操作类，初学时看了容易搞不懂，其实仔细观察其中还是有规律：这些I&#x2F;O操作类都是在<strong>继承4个基本抽象流的基础上，要么是节点流，要么是处理流</strong></p><h3 id="2-1-四个基本抽象流"><a href="#2-1-四个基本抽象流" class="headerlink" title="2.1 四个基本抽象流"></a>2.1 四个基本抽象流</h3><p>java.io包中包含了流式I&#x2F;O所需要的所有类，java.io包中有四个基本抽象流，分别处理字节流和字符流：</p><ul><li><p>InputStream</p></li><li><p>OutputStream</p></li><li><p>Reader</p></li><li><p>Writer</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124032.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124032.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>​</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124038.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124038.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>节点流I&#x2F;O类名由节点流类型 + 抽象流类型组成，常见节点类型有：</p><ul><li>File文件</li><li>Piped 进程内线程通信管道</li><li>ByteArray &#x2F; CharArray (字节数组 &#x2F; 字符数组)</li><li>StringBuffer &#x2F; String (字符串缓冲区 &#x2F; 字符串)</li></ul><p>节点流的创建通常是在构造函数传入数据源，例如：</p><pre class="line-numbers language-none"><code class="language-none">FileReader reader &#x3D; new FileReader(new File(&quot;file.txt&quot;));FileWriter writer &#x3D; new FileWriter(new File(&quot;file.txt&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><font face="黑体" color=red sice=2>2.3 处理流</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124045.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124045.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>处理流I&#x2F;O类名由对已有流封装的功能 + 抽象流类型组成，常见功能有：</p><ul><li><p><strong>缓冲</strong>：对节点流读写的数据提供了缓冲的功能，数据可以基于缓冲批量读写，提高效率。常见有BufferedInputStream、BufferedOutputStream</p></li><li><p><strong>字节流转换为字符流</strong>：由InputStreamReader、OutputStreamWriter实现</p></li><li><p><strong>字节流与基本类型数据相互转换</strong>：这里基本数据类型数据如int、long、short，由DataInputStream、DataOutputStream实现</p></li><li><p><strong>字节流与对象实例相互转换</strong>：用于实现对象序列化，由ObjectInputStream、ObjectOutputStream实现 </p><p>​</p></li></ul><p>处理流的应用了适配器&#x2F;装饰模式，转换&#x2F;扩展已有流，处理流的创建通常是在构造函数传入已有的节点流或处理流：</p><pre class="line-numbers language-none"><code class="language-none">FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;file.txt&quot;);&#x2F;&#x2F; 扩展提供缓冲写BufferedOutputStream bufferedOutputStream &#x3D; new BufferedOutputStream(fileOutputStream); &#x2F;&#x2F; 扩展提供提供基本数据类型写DataOutputStream out &#x3D; new DataOutputStream(bufferedOutputStream);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​           <font face="黑体" color=green sice=3>3 Java NIO</font></p><h3 id="3-1-标准I-x2F-O存在问题"><a href="#3-1-标准I-x2F-O存在问题" class="headerlink" title="3.1 标准I&#x2F;O存在问题"></a>3.1 标准I&#x2F;O存在问题</h3><p>Java NIO(New I&#x2F;O)是一个可以替代标准Java I&#x2F;O API的IO API(从Java 1.4开始)，Java NIO提供了与标准I&#x2F;O不同的I&#x2F;O工作方式，目的是为了解决标准 I&#x2F;O存在的以下问题：</p><ul><li>(1) 数据多次拷贝</li></ul><p>标准I&#x2F;O处理，完成一次完整的数据读写，至少需要从底层硬件读到内核空间，再读到用户文件，又从用户空间写入内核空间，再写入底层硬件</p><p>此外，底层通过write、read等函数进行I&#x2F;O系统调用时，需要传入数据所在缓冲区<strong>起始地址和长度</strong>由于JVM GC的存在，导致对象在堆中的位置往往会发生移动，移动后传入系统函数的地址参数就不是真正的缓冲区地址了</p><p>可能导致读写出错，为了解决上面的问题，使用标准I&#x2F;O进行系统调用时，还会额外导致一次数据拷贝：把数据从JVM的堆内拷贝到堆外的连续空间内存(堆外内存)</p><p>所以总共经历6次数据拷贝，执行效率较低</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124054.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124054.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><ul><li><p><strong>(2) 操作阻塞</strong></p><p>传统的网络I&#x2F;O处理中，由于请求建立连接(connect)，读取网络I&#x2F;O数据(read)，发送数据(send)等操作是线程阻塞的</p></li></ul><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 等待连接Socket socket &#x3D; serverSocket.accept();&#x2F;&#x2F; 连接已建立，读取请求消息StringBuilder req &#x3D; new StringBuilder();byte[] recvByteBuf &#x3D; new byte[1024];int len;while ((len &#x3D; socket.getInputStream().read(recvByteBuf)) !&#x3D; -1) &#123;req.append(new String(recvByteBuf, 0, len, StandardCharsets.UTF_8));&#125;&#x2F;&#x2F; 写入返回消息socket.getOutputStream().write((&quot;server response msg&quot;.getBytes()));socket.shutdownOutput();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上面服务端程序为例，当请求连接已建立，读取请求消息，服务端调用read方法时，客户端数据可能还没就绪(例如客户端数据还在写入中或者传输中)，线程需要在read方法阻塞等待直到数据就绪</p><p>为了实现服务端并发响应，每个连接需要独立的线程单独处理，当并发请求量大时为了维护连接，内存、线程切换开销过大</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124102.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124102.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><h3 id="3-2-Buffer"><a href="#3-2-Buffer" class="headerlink" title="3.2 Buffer"></a>3.2 Buffer</h3><p><strong>Java NIO核心三大核心组件是Buffer(缓冲区)、Channel(通道)、Selector</strong></p><p>Buffer提供了常用于I&#x2F;O操作的字节缓冲区，常见的缓存区有ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short，下面介绍主要以最常用的ByteBuffer为例，Buffer底层支持Java堆外内存和堆内内存</p><p><strong>堆外内存</strong>是指与堆内存相对应的，把内存对象分配在JVM堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机，相比堆内内存，I&#x2F;O操作中使用堆外内存的优势在于：</p><ul><li>不用被JVM GC线回收，减少GC线程资源占有</li><li>在I&#x2F;O系统调用时，直接操作堆外内存，可以节省一次堆外内存和堆内内存的复制</li></ul><p>ByteBuffer底层基于堆外内存的分配和释放基于malloc和free函数，对外allocateDirect方法可以申请分配堆外内存，并返回继承ByteBuffer类的DirectByteBuffer对象：</p><pre class="line-numbers language-none"><code class="language-none">public static ByteBuffer allocateDirect(int capacity) &#123;    return new DirectByteBuffer(capacity);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>堆外内存的回收基于DirectByteBuffer的成员变量Cleaner类，提供clean方法可以用于主动回收，Netty中大部分堆外内存通过记录定位Cleaner的存在，主动调用clean方法来回收；另外，当DirectByteBuffer对象被GC时，关联的堆外内存也会被回收</p><blockquote><p><strong>tips</strong>: JVM参数不建议设置-XX:+DisableExplicitGC，因为部分依赖Java NIO的框架(例如Netty)在内存异常耗尽时，会主动调用System.gc()，触发Full GC，回收DirectByteBuffer对象，作为回收堆外内存的最后保障机制，设置该参数之后会导致在该情况下堆外内存得不到清理</p></blockquote><p>堆外内存基于基础ByteBuffer类的DirectByteBuffer类成员变量：Cleaner对象，这个Cleaner对象会在合适的时候执行unsafe.freeMemory(address)，从而回收这块堆外内存</p><p>Buffer可以见到理解为一组基本数据类型，存储地址连续的的数组，支持读写操作，对应读模式和写模式，通过几个变量来保存这个数据的当前位置状态：capacity、 position、 limit：</p><ul><li>capacity 缓冲区数组的总长度</li><li>position 下一个要操作的数据元素的位置</li><li>limit 缓冲区数组中不可操作的下一个元素的位置：limit &lt;&#x3D; capacity</li></ul><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124112.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124112.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><h3 id="3-3-Channel"><a href="#3-3-Channel" class="headerlink" title="3.3 Channel"></a>3.3 Channel</h3><p>Channel(通道)的概念可以类比I&#x2F;O流对象，NIO中I&#x2F;O操作主要基于Channel：从Channel进行数据读取 ：创建一个缓冲区，然后请求Channel读取数据 从Channel进行数据写入 ：创建一个缓冲区，填充数据，请求Channel写入数据</p><p>Channel和流非常相似，主要有以下几点区别：</p><ul><li><p>Channel可以读和写，而标准I&#x2F;O流是单向的</p></li><li><p>Channel可以异步读写，标准I&#x2F;O流需要线程阻塞等待直到读写操作完成</p></li><li><p>Channel总是基于缓冲区Buffer读写</p><p>​</p></li></ul><p>Java NIO中最重要的几个Channel的实现：</p><ul><li>FileChannel：用于文件的数据读写，基于FileChannel提供的方法能减少读写文件数据拷贝次数，后面会介绍</li><li>DatagramChannel：用于UDP的数据读写</li><li>SocketChannel：用于TCP的数据读写，代表客户端连接</li><li>ServerSocketChannel: 监听TCP连接请求，每个请求会创建会一个SocketChannel，一般用于服务端</li></ul><p>基于标准I&#x2F;O中，我们第一步可能要像下面这样获取输入流，按字节把磁盘上的数据读取到程序中，再进行下一步操作，而在NIO编程中，需要先获取Channel，再进行读写</p><pre class="line-numbers language-none"><code class="language-none">FileInputStream fileInputStream &#x3D; new FileInputStream(&quot;test.txt&quot;);FileChannel channel &#x3D; fileInputStream.channel();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>tips</strong>: FileChannel仅能运行在阻塞模式下，文件异步处理的 I&#x2F;O 是在JDK 1.7 才被加入的 java.nio.channels.AsynchronousFileChannel</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F; server socket channel:ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();serverSocketChannel.bind(new InetSocketAddress(InetAddress.getLocalHost(), 9091));while (true) &#123;SocketChannel socketChannel &#x3D; serverSocketChannel.accept();ByteBuffer buffer &#x3D; ByteBuffer.allocateDirect(1024);int readBytes &#x3D; socketChannel.read(buffer);if (readBytes &gt; 0) &#123;&#x2F;&#x2F; 从写数据到buffer翻转为从buffer读数据buffer.flip();byte[] bytes &#x3D; new byte[buffer.remaining()];buffer.get(bytes);String body &#x3D; new String(bytes, StandardCharsets.UTF_8);System.out.println(&quot;server 收到：&quot; + body);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-Selector"><a href="#3-4-Selector" class="headerlink" title="3.4 Selector"></a>3.4 Selector</h3><p>Selector(选择器) ，它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。实现单线程管理多个Channel，也就是可以管理多个网络连接</p><p>Selector核心在于基于操作系统提供的I&#x2F;O复用功能，单个线程可以同时监视多个连接描述符，一旦某个连接就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，常见有select、poll、epoll等不同实现</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124122.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124122.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124126.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124126.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>Java NIO Selector基本工作原理如下：</p><ul><li>(1) 初始化Selector对象，服务端ServerSocketChannel对象</li><li>(2) 向Selector注册ServerSocketChannel的socket-accept事件</li><li>(3) 线程阻塞于selector.select()，当有客户端请求服务端，线程退出阻塞</li><li>(4) 基于selector获取所有就绪事件，此时先获取到socket-accept事件，向Selector注册客户端SocketChannel的数据就绪可读事件事件</li><li>(5) 线程再次阻塞于selector.select()，当有客户端连接数据就绪，可读</li><li>(6) 基于ByteBuffer读取客户端请求数据，然后写入响应数据，关闭channel</li></ul><p>示例如下，完整可运行代码已经上传github(<a href="https://github.com/caison/caison-blog-demo)%EF%BC%9A">https://github.com/caison/caison-blog-demo)：</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>serverSocketChannel<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">9091</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 配置通道为非阻塞模式</span>serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注册服务端的socket-accept事件</span>serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// selector.select()会一直阻塞，直到有channel相关操作就绪</span>selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// SelectionKey关联的channel都有就绪事件</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">></span></span> keyIterator <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">SelectionKey</span> key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 服务端socket-accept</span><span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 获取客户端连接的channel</span><span class="token class-name">SocketChannel</span> clientSocketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置为非阻塞模式</span>clientSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 注册监听该客户端channel可读事件，并为channel关联新分配的buffer</span>clientSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_READ<span class="token punctuation">,</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// channel可读</span><span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ByteBuffer</span> buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span> key<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> bytesRead<span class="token punctuation">;</span><span class="token class-name">StringBuilder</span> reqMsg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bytesRead <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 从buf写模式切换为读模式</span>buf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> bufRemain <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>bufRemain<span class="token punctuation">]</span><span class="token punctuation">;</span>buf<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> bytesRead<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 这里当数据包大于byteBuffer长度，有可能有粘包/拆包问题</span>reqMsg<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buf<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务端收到报文："</span> <span class="token operator">+</span> reqMsg<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>bytesRead <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token string">"[这是服务回的报文的报文]"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> offset <span class="token operator">&lt;</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> offset <span class="token operator">+=</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>length <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>length <span class="token operator">-</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>buf<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>buf<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>socketChannel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// Selector不会自己从已selectedKeys中移除SelectionKey实例</span><span class="token comment">// 必须在处理完通道时自己移除 下次该channel变成就绪时，Selector会再次将其放入selectedKeys中</span>keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>tips</strong>: Java NIO基于Selector实现高性能网络I&#x2F;O这块使用起来比较繁琐，使用不友好，一般业界使用基于Java NIO进行封装优化，扩展丰富功能的Netty框架来优雅实现</p></blockquote><p>​     <u><font face="黑体" color=green sice=9>高性能I&#x2F;O优化</font></u></p><p>下面结合业界热门开源项目介绍高性能I&#x2F;O的优化</p><h2 id="1-零拷贝"><a href="#1-零拷贝" class="headerlink" title="1 零拷贝"></a>1 零拷贝</h2><p>零拷贝(zero copy)技术，用于在数据读写中减少甚至完全避免不必要的CPU拷贝，减少内存带宽的占用，提高执行效率，零拷贝有几种不同的实现原理，下面介绍常见开源项目中零拷贝实现</p><h3 id="1-1-Kafka零拷贝"><a href="#1-1-Kafka零拷贝" class="headerlink" title="1.1 Kafka零拷贝"></a>1.1 Kafka零拷贝</h3><p>Kafka基于Linux 2.1内核提供，并在2.4 内核改进的的sendfile函数 + 硬件提供的DMA Gather Copy实现零拷贝，将文件通过socket传送</p><p>函数通过一次系统调用完成了文件的传送，减少了原来read&#x2F;write方式的模式切换。同时减少了数据的copy, sendfile的详细过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124149.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124149.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>基本流程如下：</p><ul><li>(1) 用户进程发起sendfile系统调用</li><li>(2) 内核基于DMA Copy将文件数据从磁盘拷贝到内核缓冲区</li><li>(3) 内核将内核缓冲区中的文件描述信息(文件描述符，数据长度)拷贝到Socket缓冲区</li><li>(4) 内核基于Socket缓冲区中的文件描述信息和DMA硬件提供的Gather Copy功能将内核缓冲区数据复制到网卡</li><li>(5) 用户进程sendfile系统调用完成并返回</li></ul><p>相比传统的I&#x2F;O方式，sendfile + DMA Gather Copy方式实现的零拷贝，数据拷贝次数从4次降为2次，系统调用从2次降为1次，用户进程上下文切换次数从4次变成2次DMA Copy，大大提高处理效率</p><p>Kafka底层基于java.nio包下的FileChannel的transferTo：</p><pre class="line-numbers language-none"><code class="language-none">public abstract long transferTo(long position, long count, WritableByteChannel target)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>transferTo将FileChannel关联的文件发送到指定channel，当Comsumer消费数据，Kafka Server基于FileChannel将文件中的消息数据发送到SocketChannel</p><h3 id="1-2-RocketMQ零拷贝"><a href="#1-2-RocketMQ零拷贝" class="headerlink" title="1.2 RocketMQ零拷贝"></a>1.2 RocketMQ零拷贝</h3><p>RocketMQ基于mmap + write的方式实现零拷贝：mmap() 可以将内核中缓冲区的地址与用户空间的缓冲区进行映射，实现数据共享，省去了将数据从内核缓冲区拷贝到用户缓冲区</p><pre class="line-numbers language-none"><code class="language-none">tmp_buf &#x3D; mmap(file, len);write(socket, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124155.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124155.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>mmap + write 实现零拷贝的基本流程如下：</p><ul><li>(1) 用户进程向内核发起系统mmap调用</li><li>(2) 将用户进程的内核空间的读缓冲区与用户空间的缓存区进行内存地址映射</li><li>(3) 内核基于DMA Copy将文件数据从磁盘复制到内核缓冲区</li><li>(4) 用户进程mmap系统调用完成并返回</li><li>(5) 用户进程向内核发起write系统调用</li><li>(6) 内核基于CPU Copy将数据从内核缓冲区拷贝到Socket缓冲区</li><li>(7) 内核基于DMA Copy将数据从Socket缓冲区拷贝到网卡</li><li>(8) 用户进程write系统调用完成并返回</li></ul><p>RocketMQ中消息基于mmap实现存储和加载的逻辑写在org.apache.rocketmq.store.MappedFile中，内部实现基于nio提供的java.nio.MappedByteBuffer，基于FileChannel的map方法得到mmap的缓冲区：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 初始化this.fileChannel &#x3D; new RandomAccessFile(this.file, &quot;rw&quot;).getChannel();this.mappedByteBuffer &#x3D; this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查询CommitLog的消息时，基于mappedByteBuffer偏移量pos，数据大小size查询：</p><pre class="line-numbers language-none"><code class="language-none">public SelectMappedBufferResult selectMappedBuffer(int pos, int size) &#123;int readPosition &#x3D; getReadPosition();&#x2F;&#x2F; ...各种安全校验    &#x2F;&#x2F; 返回mappedByteBuffer视图ByteBuffer byteBuffer &#x3D; this.mappedByteBuffer.slice();byteBuffer.position(pos);ByteBuffer byteBufferNew &#x3D; byteBuffer.slice();byteBufferNew.limit(size);return new SelectMappedBufferResult(this.fileFromOffset + pos, byteBufferNew, size, this);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>tips: transientStorePoolEnable机制</strong>Java NIO mmap的部分内存并不是常驻内存，可以被置换到交换内存(虚拟内存)，RocketMQ为了提高消息发送的性能，引入了内存锁定机制，即将最近需要操作的CommitLog文件映射到内存，并提供内存锁定功能，确保这些文件始终存在内存中，该机制的控制参数就是transientStorePoolEnable</p></blockquote><p>因此，MappedFile数据保存CommitLog刷盘有2种方式：</p><ul><li>1 开启transientStorePoolEnable：写入内存字节缓冲区(writeBuffer)  -&gt; 从内存字节缓冲区(writeBuffer)提交(commit)到文件通道(fileChannel)  -&gt; 文件通道(fileChannel) -&gt; flush到磁盘</li><li>2 未开启transientStorePoolEnable：写入映射文件字节缓冲区(mappedByteBuffer) -&gt; 映射文件字节缓冲区(mappedByteBuffer) -&gt; flush到磁盘</li></ul><p>RocketMQ 基于 mmap+write 实现零拷贝，适用于业务级消息这种小块文件的数据持久化和传输 Kafka 基于 sendfile 这种零拷贝方式，适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输</p><blockquote><p><strong>tips:</strong> Kafka 的索引文件使用的是 mmap+write 方式，数据文件发送网络使用的是 sendfile 方式</p></blockquote><h3 id="1-3-Netty零拷贝"><a href="#1-3-Netty零拷贝" class="headerlink" title="1.3 Netty零拷贝"></a>1.3 Netty零拷贝</h3><p>Netty 的零拷贝分为两种：</p><ul><li><p>1 基于操作系统实现的零拷贝，底层基于FileChannel的transferTo方法</p></li><li><p>2 基于Java 层操作优化，对数组缓存对象(ByteBuf )进行封装优化，通过对ByteBuf数据建立数据视图，支持ByteBuf 对象合并，切分，当底层仅保留一份数据存储，减少不必要拷贝</p><p>​</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>​     <u><font face="黑体" color=green sice=9>2 多路复用</font></u></p><p>Netty中对Java NIO功能封装优化之后，实现I&#x2F;O多路复用代码优雅了很多：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建mainReactor</span><span class="token class-name">NioEventLoopGroup</span> boosGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 创建工作线程组</span><span class="token class-name">NioEventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> <span class="token class-name">ServerBootstrap</span> serverBootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>serverBootstrap <span class="token comment">// 组装NioEventLoopGroup</span><span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>boosGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span> <span class="token comment">// 设置channel类型为NIO类型</span><span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment">// 设置连接配置参数</span><span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment">// 配置入站、出站事件handler</span><span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 配置入站、出站事件channel</span>ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 绑定端口</span><span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span>serverBootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span>future <span class="token operator">-></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">": 端口["</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">"]绑定成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"端口["</span> <span class="token operator">+</span> port <span class="token operator">+</span> <span class="token string">"]绑定失败!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   <u><font face="黑体" color=green sice=7>3 页缓存(PageCache)</font></u></p><p>页缓存（PageCache)是操作系统对文件的缓存，用来减少对磁盘的 I&#x2F;O 操作，以页为单位的，内容就是磁盘上的物理块，页缓存能帮助<strong>程序对文件进行顺序读写的速度几乎接近于内存的读写速度</strong>，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化：</p><p><strong>页缓存读取策略</strong>：当进程发起一个读操作 （比如，进程发起一个 read() 系统调用），它首先会检查需要的数据是否在页缓存中：</p><ul><li>如果在，则放弃访问磁盘，而直接从页缓存中读取</li><li>如果不在，则内核调度块 I&#x2F;O 操作从磁盘去读取数据，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），然后将数据放入页缓存中</li></ul><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124202.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200308124202.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><strong>页缓存写策略</strong>：当进程发起write系统调用写数据到文件中，先写到页缓存，然后方法返回。此时数据还没有真正的保存到文件中去，Linux 仅仅将页缓存中的这一页数据标记为“脏”，并且被加入到脏页链表中</p><p>然后，由flusher 回写线程周期性将脏页链表中的页写到磁盘，让磁盘中的数据和内存中保持一致，最后清理“脏”标识。在以下三种情况下，脏页会被写回磁盘:</p><ul><li>空闲内存低于一个特定阈值</li><li>脏页在内存中驻留超过一个特定的阈值时</li><li>当用户进程调用 sync() 和 fsync() 系统调用时</li></ul><p>RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能，提供了2种消息刷盘策略：</p><ul><li>同步刷盘：在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应</li><li>异步刷盘，能充分利用操作系统的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量</li></ul><p>Kafka实现消息高性能读写也利用了页缓存，这里不再展开</p><p>​                                             ##<code>参考</code></p><p>《深入理解Linux内核 》</p><p>Netty之Java堆外内存扫盲贴 </p><p>Java NIO？看这一篇就够了！</p><p>RocketMQ 消息存储流程 </p><p>一文理解Netty模型架构 </p>]]></content>
      
      
      <categories>
          
          <category> IO流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不使用synchronized和lock，如何实现一个线程安全的单例？</title>
      <link href="/blog/2020/03/06/bu-shi-yong-synchronized-he-lock-ru-he-shi-xian-yi-ge-xian-cheng-an-quan-de-dan-li/"/>
      <url>/blog/2020/03/06/bu-shi-yong-synchronized-he-lock-ru-he-shi-xian-yi-ge-xian-cheng-an-quan-de-dan-li/</url>
      
        <content type="html"><![CDATA[<p>单例，大家肯定都不陌生，这是Java中很重要的一个设计模式。稍微了解一点单例的朋友也都知道实现单例是要考虑并发问题的，一般情况下，我们都会使用synchronized来保证线程安全。</p><p>那么，：<strong>不使用synchronized和lock，如何实现一个线程安全的单例？</strong>你该如何回答？</p><p>C类应聘者：可以使用饿汉模式实现单例。如：</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton &#123;     private static Singleton instance &#x3D; new Singleton();    private Singleton ()&#123;&#125;    public static Singleton getInstance() &#123;      return instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有部分程序员可以想到饿汉的变种：</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton &#123;    private Singleton instance &#x3D; null;    static &#123;        instance &#x3D; new Singleton();    &#125;    private Singleton ()&#123;&#125;    public static Singleton getInstance() &#123;        return this.instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用static来定义静态成员变量或静态代码，借助Class的类加载机制实现线程安全单例。</p><p><strong>面试官：除了这种以外，还有其他方式吗？</strong></p><p>B类应聘者：</p><p>除了以上两种方式，还有一种办法，就是通过静态内部类来实现，代码如下：</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton &#123;    private static class SingletonHolder &#123;        private static final Singleton INSTANCE &#x3D; new Singleton();    &#125;    private Singleton ()&#123;&#125;    public static final Singleton getInstance() &#123;        return SingletonHolder.INSTANCE;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式相比前面两种有所优化，就是使用了lazy-loading。Singleton类被装载了，但是instance并没有立即初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。</p><p><strong>面试官：除了这种以外，还有其他方式吗？</strong></p><p>A类应聘者：</p><p>除了以上方式，还可以使用枚举的方式，如：</p><pre class="line-numbers language-none"><code class="language-none">public enum Singleton &#123;    INSTANCE;    public void whateverMethod() &#123;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒。</p><p>面试官：以上几种答案，其实现原理都是利用借助了类加载的时候初始化单例。即借助了ClassLoader的线程安全机制。</p><p>所谓ClassLoader的线程安全机制，就是ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。也正是因为这样， 除非被重写，这个方法默认在整个装载过程中都是同步的，也就是保证了线程安全。</p><p>所以，以上各种方法，虽然并没有显示的使用synchronized，但是还是其底层实现原理还是用到了synchronized。</p><p><strong>面试官：除了这种以外，还有其他方式吗？</strong></p><p>A类应聘者：</p><p>还可以使用Java并发包中的Lock实现</p><p><strong>面试官：本质上还是在使用锁，不使用锁的话，有办法实现线程安全的单例吗？</strong></p><p>A+类面试者：</p><p>有的，那就是使用CAS。</p><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。实现单例的方式如下：</p><pre class="line-numbers language-none"><code class="language-none">public class Singleton &#123;    private static final AtomicReference&lt;Singleton&gt; INSTANCE &#x3D; new AtomicReference&lt;Singleton&gt;();    private Singleton() &#123;&#125;    public static Singleton getInstance() &#123;        for (;;) &#123;            Singleton singleton &#x3D; INSTANCE.get();            if (null !&#x3D; singleton) &#123;                return singleton;            &#125;            singleton &#x3D; new Singleton();            if (INSTANCE.compareAndSet(null, singleton)) &#123;                return singleton;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>面试官：这种方式实现的单例有啥优缺点吗？</strong></p><p>A++类面试者：</p><p>用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。</p><p>CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销。</p><p>另外，如果N个线程同时执行到singleton &#x3D; new Singleton();的时候，会有大量对象创建，很可能导致内存溢出。</p><p><strong>面试官：你被录取了！</strong></p><h1 id="maven在依赖下载过程中中断怎么办"><a href="#maven在依赖下载过程中中断怎么办" class="headerlink" title="maven在依赖下载过程中中断怎么办"></a><a href="https://www.cnblogs.com/duowenjia/p/12120275.html">maven在依赖下载过程中中断怎么办</a></h1><p>1.打开cmd</p><p>2.找到本地仓库</p><p>3.执行for &#x2F;r %i in (*.lastUpdated) do del %i</p><p>这是为了删除所有lastUpdated后缀的文件，这样就能重新下载依赖了</p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 悦读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句大全，所有的SQL都在这里</title>
      <link href="/blog/2020/03/06/sql-yu-ju-da-quan-suo-you-de-sql-du-zai-zhe-li/"/>
      <url>/blog/2020/03/06/sql-yu-ju-da-quan-suo-you-de-sql-du-zai-zhe-li/</url>
      
        <content type="html"><![CDATA[<p>​                   <font face="黑体" color=red>一、基础</font></p><p><strong>1、说明：创建数据库CREATE DATABASE database-name</strong><br>2、说明：删除数据库drop database dbname                                        3、说明：备份sql server— 创建 备份数据的 deviceUSE masterEXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’— 开始 备份BACKUP DATABASE pubs TO testBack </p><p><strong>4、说明：创建新表create table tabname(col1 type1 [not null][primary key],col2 type2 [not null],..)</strong></p><p><strong>根据已有的表创建新表： **<br><strong>A：create table tab_new like tab_old (使用旧表创建新表)</strong><br><strong>B<strong><strong>：create table tab_new as select col1,col2… from tab_old definition only</strong></strong>5、说明：删除新表drop table tabname</strong><br><strong>6、说明：增加一个列Alter table tabname add column col type****注</strong>：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。<br><strong>7、说明：添加主键</strong>： <strong>Alter table tabname add primary key(col) <strong>说明：删除主键：</strong> Alter table tabname drop primary key(col) *<em><strong>8、说明：创建索引</strong>：</em>*create [unique] index idxname on tabname(col….) <strong>删除索引：</strong>drop index idxname</strong><br>注：索引是不可更改的，想更改必须删除重新建。<br><strong>9****、说明：创建视图</strong>：create view viewname as select statement<br><strong>删除视图</strong>：drop view viewname<br><strong>10****、说明：几个简单的基本的sql语句选择：</strong>select * from table1 where 范围<br><strong>插入：</strong>insert into table1(field1,field2) values(value1,value2)<br><strong>删除：</strong>delete from table1 where 范围</strong>更新**：update table1 set field1&#x3D;value1 where 范围<br><strong>查找</strong>：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!<br><strong>排序</strong>：select * from table1 order by field1,field2 [desc]<br><strong>总数</strong>：select count as totalcount from table1<br><strong>求和</strong>：select sum(field1) as sumvalue from table1<br><strong>平均</strong>：select avg(field1) as avgvalue from table1<br><strong>最大</strong>：select max(field1) as maxvalue from table1<br><strong>最小</strong>：select min(field1) as minvalue from table1<br><strong>11、说明：几个高级查询运算词A： UNION 运算符</strong><br>UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 </p><p><strong>B： EXCEPT 运算符 EXCEPT</strong>运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。</p><p><strong>C： INTERSECT 运算符INTERSECT</strong>运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 <strong>ALL</strong>随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。 </p><p><strong>注：</strong>使用运算词的几个查询结果行必须是一致的。<br><strong>12****、说明：使用外连接 <strong>A、</strong>left （outer） join</strong>：<br>左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。<br>SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a &#x3D; b.c<br>**B：right （outer） join: **<br>右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。<br><strong>C：full&#x2F;cross （outer） join</strong>：<br>全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。<br>*<em>12</em>***、分组:Group by:   **一张表，一旦分组 完成后，查询后只能得到组相关的信息。</p><p>​    <strong>组相关的信息：</strong>（统计信息） count,sum,max,min,avg ** **<strong>分组的标准)  ****  在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据   在selecte统计函数中的字段，不能和普通的字段放在一起；</strong></p><p><strong>13、对数据库进行操作：   分离数据库</strong>：sp_detach_db;附加数据库<strong>：</strong>sp_attach_db 后接表明，附加需要完整的路径名<br>14.如何修改数据库的名称:<br>sp_renamedb ‘old_name’, ‘new_name’</p><p>​                  <font face="黑体" color=red  size=6>二、提升</font></p><p><strong>1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)法一：</strong>select * into b from a where 1&lt;&gt;1（仅用于SQlServer）<strong>法二：</strong>select top 0 * into b from a<br>**2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)**insert into b(a, b, c) select d,e,f from b;</p><p>**3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)**insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件<br>例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”‘ where..</p><p>**4、说明：子查询(表名1：a 表名2：b)**select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</p><p><strong>5、说明：显示文章、提交人和最后回复时间</strong>select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title&#x3D;a.title) b</p><p>**6、说明：外连接查询(表名1：a 表名2：b)**select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a &#x3D; b.c</p><p>**7、说明：在线视图查询(表名1：a )**select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</p><p><strong>8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括</strong>select * from table1 where time between time1 and time2<br>select a,b,c, from table1 where a not between 数值1 and 数值2</p><p><strong>9、说明：in 的使用方法</strong>select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</p><p>**10、说明：两张关联表，删除主表中已经在副表中没有的信息 **delete from table1 where not exists ( select * from table2 where table1.field1&#x3D;table2.field1 )</p><p><strong>11、说明：四表联查问题：</strong>select * from a left inner join b on a.a&#x3D;b.b right inner join c on a.a&#x3D;c.c inner join d on a.a&#x3D;d.d where …..</p><p>**12、说明：日程安排提前五分钟提醒 **SQL: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</p><p><strong>13<strong><strong>、说明：一条</strong></strong>sql *<em><strong>语句搞定数据库分页</strong>select top 10 b.</em> from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 &#x3D; a.主键字段 order by a.排序字段**具体实现：</strong>关于数据库分页：</p><p>  declare @start int,@end int</p><p>  @sql  nvarchar(600)</p><p>  set @sql&#x3D;’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</p><p>  exec sp_executesql @sql</p><p><strong>注意：在<strong><strong>top</strong></strong>后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。<strong><strong>Rid</strong></strong>为一个标识列，如果<strong><strong>top</strong></strong>后还有具体的字段，这样做是非常有好处的。因为这样可以避免**</strong> top<strong><strong>的字段如果是逻辑索引的，查询的结果后实际表中的不一致（</strong></strong>逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引**<strong>）</strong></p><p><strong>14、说明：前10条记录</strong>select top 10 * form table1 where 范围</p><p>**15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)**select a,b,c from tablename ta where a&#x3D;(select max(a) from tablename tb where tb.b&#x3D;ta.b)</p><p><strong>16、说明：包括所有在 TableA中但不在 TableB和TableC中的行并消除所有重复行而派生出一个结果表</strong>(select a from tableA ) except (select a from tableB) except (select a from tableC)</p><p><strong>17、说明：随机取出10条数据</strong>select top 10 * from tablename order by <strong>newid()</strong></p><p><strong>18、说明：随机选择记录</strong>select newid()</p><p>**19、说明：删除重复记录1),**delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)<br><strong>2)</strong>,select distinct * into temp from tablename<br>  delete from tablename<br>  insert into tablename select * from temp<br><strong>评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段</strong></p><p>alter table tablename<br>–添加一个自增列<br>add  column_b int identity(1,1)<br> delete from tablename where column_b not in(<br>select max(column_b)  from tablename group by column1,column2,…)<br>alter table tablename drop column column_b</p><p><strong>20、说明：列出数据库里所有的表名</strong>select name from sysobjects where type&#x3D;’U’ &#x2F;&#x2F; U代表用户</p><p><strong>21、说明：列出表里的所有的列名</strong>select name from syscolumns where id&#x3D;object_id(‘TableName’)</p><p><strong>22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。</strong>select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’ then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablename group by type<br><strong>显示结果：type vender pcs</strong>电脑 A 1<br>电脑 A 1<br>光盘 B 2<br>光盘 A 2<br>手机 B 3<br>手机 C 3</p><p><strong>23、说明：初始化表table1</strong></p><p>TRUNCATE TABLE table1</p><p><strong>24、说明：选择从10到15的记录</strong>select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</p><p>​     <font face="黑体" color=red  size=6>三、技巧</font></p><p><strong>1、1&#x3D;1，1&#x3D;2的使用，在SQL语句组合时用的较多</strong></p><p><strong>“where 1&#x3D;1” 是表示选择全部    “where 1&#x3D;2”全部不选，</strong><br>如：<br>if @strWhere !&#x3D;’’<br>begin<br>set @strSQL &#x3D; ‘select count(<em>) as Total from [‘ + @tblName + ‘] where ‘ + @strWhere<br>end<br>else<br>begin<br>set @strSQL &#x3D; ‘select count(</em>) as Total from [‘ + @tblName + ‘]’<br>end</p><p><strong>我们可以直接写成</strong></p><p>错误！未找到目录项。<strong>set @strSQL &#x3D; ‘select count(*) as Total from [‘ + @tblName + ‘] where 1&#x3D;1 安定 ‘+ @strWhere 2、收缩数据库</strong>–重建索引<br>DBCC REINDEX<br>DBCC INDEXDEFRAG<br>–收缩数据和日志<br>DBCC SHRINKDB<br>DBCC SHRINKFILE</p><p><strong>3、压缩数据库</strong>dbcc shrinkdatabase(dbname)</p><p><strong>4、转移数据库给新用户以已存在用户权限</strong>exec sp_change_users_login ‘update_one’,’newname’,’oldname’<br>go</p><p><strong>5、检查备份集</strong>RESTORE VERIFYONLY from disk&#x3D;’E:\dvbbs.bak’</p><p><strong>6、修复数据库</strong>ALTER DATABASE [dvbbs] SET SINGLE_USER<br>GO<br>DBCC CHECKDB(‘dvbbs’,repair_allow_data_loss) WITH TABLOCK<br>GO<br>ALTER DATABASE [dvbbs] SET MULTI_USER<br>GO</p><p><strong>7、日志清除</strong>SET NOCOUNT ON<br>DECLARE @LogicalFileName sysname,<br> @MaxMinutes INT,<br> @NewSize INT</p><p>USE tablename – 要操作的数据库名<br>SELECT  @LogicalFileName &#x3D; ‘tablename_log’, – 日志文件名<br>@MaxMinutes &#x3D; 10, – Limit on time allowed to wrap log.<br> @NewSize &#x3D; 1  – 你想设定的日志文件的大小(M)</p><p>Setup &#x2F; initialize<br>DECLARE @OriginalSize int<br>SELECT @OriginalSize &#x3D; size<br> FROM sysfiles<br> WHERE name &#x3D; @LogicalFileName<br>SELECT ‘Original Size of ‘ + db_name() + ‘ LOG is ‘ +<br> CONVERT(VARCHAR(30),@OriginalSize) + ‘ 8K pages or ‘ +<br> CONVERT(VARCHAR(30),(@OriginalSize*8&#x2F;1024)) + ‘MB’<br> FROM sysfiles<br> WHERE name &#x3D; @LogicalFileName<br>CREATE TABLE DummyTrans<br> (DummyColumn char (8000) not null)</p><p>DECLARE @Counter    INT,<br> @StartTime DATETIME,<br> @TruncLog   VARCHAR(255)<br>SELECT @StartTime &#x3D; GETDATE(),<br> @TruncLog &#x3D; ‘BACKUP LOG ‘ + db_name() + ‘ WITH TRUNCATE_ONLY’</p><p>DBCC SHRINKFILE (@LogicalFileName, @NewSize)<br>EXEC (@TruncLog)<br>– Wrap the log if necessary.<br>WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) – time has not expired<br> AND @OriginalSize &#x3D; (SELECT size FROM sysfiles WHERE name &#x3D; @LogicalFileName)<br> AND (@OriginalSize * 8 &#x2F;1024) &gt; @NewSize<br> BEGIN – Outer loop.<br>SELECT @Counter &#x3D; 0<br> WHILE   ((@Counter &lt; @OriginalSize &#x2F; 16) AND (@Counter &lt; 50000))<br> BEGIN – update<br> INSERT DummyTrans VALUES (‘Fill Log’) DELETE DummyTrans<br> SELECT @Counter &#x3D; @Counter + 1<br> END<br> EXEC (@TruncLog)<br> END<br>SELECT ‘Final Size of ‘ + db_name() + ‘ LOG is ‘ +<br> CONVERT(VARCHAR(30),size) + ‘ 8K pages or ‘ +<br> CONVERT(VARCHAR(30),(size*8&#x2F;1024)) + ‘MB’<br> FROM sysfiles<br> WHERE name &#x3D; @LogicalFileName<br>DROP TABLE DummyTrans<br>SET NOCOUNT OFF</p><p><strong>8、说明：更改某个表</strong>exec sp_changeobjectowner ‘tablename’,’dbo’</p><p><strong>9、存储更改全部表</strong></p><p>CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch<br>@OldOwner as NVARCHAR(128),<br>@NewOwner as NVARCHAR(128)<br>AS</p><p>DECLARE @Name    as NVARCHAR(128)<br>DECLARE @Owner   as NVARCHAR(128)<br>DECLARE @OwnerName   as NVARCHAR(128)</p><p>DECLARE curObject CURSOR FOR<br>select ‘Name’    &#x3D; name,<br>   ‘Owner’    &#x3D; user_name(uid)<br>from sysobjects<br>where user_name(uid)&#x3D;@OldOwner<br>order by name</p><p>OPEN   curObject<br>FETCH NEXT FROM curObject INTO @Name, @Owner<br>WHILE(@@FETCH_STATUS&#x3D;0)<br>BEGIN<br>if @Owner&#x3D;@OldOwner<br>begin<br>   set @OwnerName &#x3D; @OldOwner + ‘.’ + rtrim(@Name)<br>   exec sp_changeobjectowner @OwnerName, @NewOwner<br>end<br>– select @name,@NewOwner,@OldOwner</p><p>FETCH NEXT FROM curObject INTO @Name, @Owner<br>END</p><p>close curObject<br>deallocate curObject<br>GO</p><p><strong>10、SQL SERVER中直接循环写入数据</strong>declare @i int<br>set @i&#x3D;1<br>while @i&lt;30<br>begin<br>​    insert into test (userid) values(@i)<br>​    set @i&#x3D;@i+1<br>end<br><strong>案例<strong><strong>：</strong></strong>有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:</strong></p><p>​    Name     score</p><p>​    Zhangshan   80</p><p>​    Lishi       59</p><p>​    Wangwu      50</p><p>​    Songquan    69</p><p><strong>while((select <strong><strong>min</strong></strong>(score) from tb_table)&lt;<strong><strong>60</strong></strong>)</strong></p><p><strong>begin</strong></p><p>**update tb_table set score ****&#x3D;****score***<strong>1.01</strong></p><p><strong>where score</strong><strong>&lt;60</strong></p><p><strong>if  (select <strong><strong>min</strong></strong>(score) from tb_table)****&gt;60</strong></p><p>**  break**</p><p>** else**</p><p>**    continue**</p><p><strong>end</strong></p><p>  <font face="黑体" color=red  size=6>数据开发-经典</font></p><p><strong>1.按姓氏笔画排序:</strong><br>Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as &#x2F;&#x2F;从少到多</p><p>**2.数据库加密:**select encrypt(‘原始密码’)<br>select pwdencrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’) &#x3D; 1–相同；否则不相同 encrypt(‘原始密码’)<br>select pwdencrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’) &#x3D; 1–相同；否则不相同</p><p>**3.取回表中字段:**declare @list varchar(1000),<br>@sql nvarchar(1000)<br>select @list&#x3D;@list+’,’+b.name from sysobjects a,syscolumns b where a.id&#x3D;b.id and a.name&#x3D;’表A’<br>set @sql&#x3D;’select ‘+right(@list,len(@list)-1)+’ from 表A’<br>exec (@sql)</p><p><strong>4.查看硬盘分区:EXEC master..xp_fixeddrives</strong></p><p>**5.比较A,B表是否相等:*<em>if (select checksum_agg(binary_checksum(</em>)) from A)<br>​     &#x3D;<br>​    (select checksum_agg(binary_checksum(*)) from B)<br>print ‘相等’<br>else<br>print ‘不相等’</p><p>**6.杀掉所有的事件探察器进程:**DECLARE hcforeach CURSOR GLOBAL FOR SELECT ‘kill ‘+RTRIM(spid) FROM master.dbo.sysprocesses<br>WHERE program_name IN(‘SQL profiler’,N’SQL 事件探查器’)<br>EXEC sp_msforeach_worker ‘?’</p><p>*<em>7.<strong><strong>记录搜索</strong></strong>:<strong><strong>开头到</strong></strong>N</em><em><strong>条记录</strong>Select Top N * From 表——————————-<br><strong>N</strong></em><em>到</em><em><strong>M</strong></em><em>条记录</em><em>**(<strong><strong>要有主索引</strong></strong>ID)*<em>Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID   Desc<br>-———————————<br><strong>N</strong></em>*到结尾记录**Select Top N * From 表 Order by ID Desc<br><strong>案例</strong></em><em>例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第</em><em><strong>31</strong></em><em>到第</em><em><strong>40</strong></em><em>个记录。</em>*</p><p> select top 10 recid from A where recid not  in(select top 30 recid from A)</p><p>分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。</p><p>​    select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。</p><p><strong>解决方案</strong></p><p>*<em>1，</em>***用order by **select top 30 recid from A order by ricid <strong>如果该字段不是自增长，就会出现问题</strong></p><p><strong>2，****在那个子查询中也加条件：</strong>select top 30 recid from A where recid&gt;-1</p><p>*<em>例2</em>***：查询表中的最后以条记录，并不知道这个表共有多少数据,**<strong>以及表结构。set @s &#x3D; ‘select top 1 * from T   where pid not in (select top ‘ + str(@count-1) + ‘ pid  from  T)’</strong></p><p><strong>print @s      exec  sp_executesql  @s</strong></p><p><strong>9：获取当前数据库中的所有用户表</strong><br>select Name from sysobjects where xtype&#x3D;’u’ and status&gt;&#x3D;0</p><p><strong>10：获取某一个表的所有字段</strong>select name from syscolumns where id&#x3D;object_id(‘表名’)</p><p>select name from syscolumns where id in (select id from sysobjects where type &#x3D; ‘u’ and name &#x3D; ‘表名’)</p><p>两种方式的效果相同</p><p><strong>11：查看与某一个表相关的视图、存储过程、函数</strong>select a.* from sysobjects a, syscomments b where a.id &#x3D; b.id and b.text like ‘%表名%’</p><p><strong>12：查看当前数据库中所有存储过程</strong>select name as 存储过程名称 from sysobjects where xtype&#x3D;’P’</p><p><strong>13：查询用户创建的所有数据库</strong>select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name&#x3D;’sa’)<br>或者<br>select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01</p><p><strong>14：查询某一个表的字段和数据类型</strong>select column_name,data_type from information_schema.columns<br>where table_name &#x3D; ‘表名’</p><p><strong>15****：不同服务器数据库之间的数据操作</strong></p><p>**–**<strong>创建链接服务器</strong></p><p>exec sp_addlinkedserver   ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p><p>exec sp_addlinkedsrvlogin  ‘ITSV ‘, ‘false ‘,null, ‘用户名 ‘, ‘密码 ‘</p><p>–查询示例</p><p>select * from ITSV.数据库名.dbo.表名</p><p>–导入示例</p><p>select * into 表 from ITSV.数据库名.dbo.表名</p><p>**–**<strong>以后不再使用时删除链接服务器</strong></p><p>exec sp_dropserver  ‘ITSV ‘, ‘droplogins ‘</p><hr><p>**–**<strong>连接远程&#x2F;局域网数据</strong>(openrowset&#x2F;openquery&#x2F;opendatasource)</p><p>–1、openrowset</p><p>–查询示例</p><p>select * from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><p>–生成本地表</p><p>select * into 表 from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><p>–把本地表导入远程表</p><p>insert openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><p>select *from 本地表</p><p>–更新本地表</p><p>update b</p><p>set b.列A&#x3D;a.列A</p><p> from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)as a inner join 本地表 b</p><p>on a.column1&#x3D;b.column1</p><p>–openquery用法需要创建一个连接</p><p>–首先创建一个连接创建链接服务器</p><p>exec sp_addlinkedserver   ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p><p>–查询</p><p>select *</p><p>FROM openquery(ITSV,  ‘SELECT *  FROM 数据库.dbo.表名 ‘)</p><p>–把本地表导入远程表</p><p>insert openquery(ITSV,  ‘SELECT *  FROM 数据库.dbo.表名 ‘)</p><p>select * from 本地表</p><p>–更新本地表</p><p>update b</p><p>set b.列B&#x3D;a.列B</p><p>FROM openquery(ITSV,  ‘SELECT * FROM 数据库.dbo.表名 ‘) as a </p><p>inner join 本地表 b on a.列A&#x3D;b.列A</p><p>–3、opendatasource&#x2F;openrowset</p><p>SELECT   *</p><p>FROM   opendatasource( ‘SQLOLEDB ‘,  ‘Data Source&#x3D;ip&#x2F;ServerName;User ID&#x3D;登陆名;Password&#x3D;密码 ‘ ).test.dbo.roy_ta</p><p>–把本地表导入远程表</p><p>insert opendatasource( ‘SQLOLEDB ‘,  ‘Data Source&#x3D;ip&#x2F;ServerName;User ID&#x3D;登陆名;Password&#x3D;密码 ‘).数据库.dbo.表名</p><p>select * from 本地表 </p><p>  <font face="黑体" color=red  size=6>SQL Server  基本函数</font></p><p>SQL Server基本函数</p><p>**1.字符串函数 **长度与分析用</p><p><strong>1,datalength</strong>(Char_expr) 返回字符串包含字符数,但不包含后面的空格<strong>2,substring</strong>(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度<strong>3,right</strong>(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用<strong>left</strong>于之相反<br>**4,isnull( <em><strong>check</strong></em>_***expression ***,** *replacement_value ***)**如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类</p><p><strong>5,Sp_addtype</strong>自定義數據類型<br>例如：EXEC sp_addtype birthday, datetime, ‘NULL’</p><pre class="line-numbers language-none"><code class="language-none">6,set nocount &#123;on|off&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。SET NOCOUNT 为 OFF 时，返回计数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">常识<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">在SQL查询中：from后最多可以跟多少张表或视图：256<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">在SQL语句中出现 Order by,查询时，先排序，后取<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">        <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SQLServer2000同步复制技术实现步骤<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">一、 预备工作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--管理工具<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--计算机管理<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--用户和组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--右键用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--新建用户<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--建立一个隶属于administrator组的登陆windows的用户（SynUser）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">我的电脑--D:\ 新建一个目录,名为: PUB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--右键这个新建的目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--属性--共享<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--选择&quot;共享该文件夹&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--通过&quot;权限&quot;按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--确定<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布&#x2F;订阅服务器均做此设置)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">开始--程序--管理工具--服务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--右键SQLSERVERAGENT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--属性--登陆--选择&quot;此账户&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--输入或者选择第一步中创建的windows登录用户名（SynUser）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;密码&quot;中输入该用户的密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">4.设置SQL Server身份验证模式,解决连接时的权限问题(发布&#x2F;订阅服务器均做此设置)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">企业管理器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--右键SQL实例--属性<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--安全性--身份验证<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--选择&quot;SQL Server 和 Windows&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--确定<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">5.在发布服务器和订阅服务器上互相注册<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">企业管理器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--右键SQL Server组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--新建SQL Server注册...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--下一步--可用的服务器中,输入你要注册的远程服务器名 --添加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--下一步--连接使用,选择第二个&quot;SQL Server身份验证&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--下一步--输入用户名和密码（SynUser）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--下一步--选择SQL Server组,也可以创建一个新组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--下一步--完成<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">6.对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">开始--程序--Microsoft SQL Server--客户端网络实用工具<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--别名--添加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--网络库选择&quot;tcp&#x2F;ip&quot;--服务器别名输入SQL服务器名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--连接参数--服务器名称中输入SQL服务器ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--如果你修改了SQL的端口,取消选择&quot;动态决定端口&quot;,并输入对应的端口号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">二、 正式配置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1、配置发布服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">打开企业管理器，在发布服务器（B、C、D）上执行以下步骤:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(3) [下一步] 设置快照文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">采用默认\\servername\Pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(4) [下一步] 自定义配置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">否,使用下列默认设置（推荐）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(5) [下一步] 设置分发数据库名称和位置 采用默认值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(6) [下一步] 启用发布服务器 选择作为发布的服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(7) [下一步] 选择需要发布的数据库和发布类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(8) [下一步] 选择注册订阅服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(9) [下一步] 完成配置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2、创建出版物<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">发布服务器B、C、D上<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(2)选择要创建出版物的数据库，然后单击[创建发布]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">但是在这里我们选择运行&quot;SQL SERVER 2000&quot;的数据库服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(6)选择发布名称和描述<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(7)自定义发布属性 向导提供的选择:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">否 根据指定方式创建发布 （建议采用自定义的方式）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(8)[下一步] 选择筛选发布的方式<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(9)[下一步] 可以选择是否允许匿名订阅<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">方法: [工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">如果仍然需要匿名订阅则用以下解决办法<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">[企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项] 选择允许匿名请求订阅<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(10)[下一步] 设置快照 代理程序调度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(11)[下一步] 完成配置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">有数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">srv1.库名..author有字段:id,name,phone, <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">srv2.库名..author有字段:id,name,telphone,adress <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">要求：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">srv1.库名..author增加记录则srv1.库名..author记录增加<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--*&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--大致的处理步骤<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">exec sp_addlinkedserver &#39;srv2&#39;,&#39;&#39;,&#39;SQLOLEDB&#39;,&#39;srv2的sql实例名或ip&#39; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">exec sp_addlinkedsrvlogin &#39;srv2&#39;,&#39;false&#39;,null,&#39;用户名&#39;,&#39;密码&#39; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">go<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">。我的电脑--控制面板--管理工具--服务--右键 Distributed Transaction Coordinator--属性--启动--并将启动类型设置为自动启动<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">go <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--然后创建一个作业定时调用上面的同步处理存储过程就行了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">企业管理器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--管理<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--SQL Server代理<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--右键作业<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--新建作业<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;常规&quot;项中输入作业名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;步骤&quot;项<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--新建<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;步骤名&quot;中输入步骤名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;类型&quot;中选择&quot;Transact-SQL 脚本(TSQL)&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;数据库&quot;选择执行命令的数据库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;命令&quot;中输入要执行的语句: exec p_process <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--确定<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;调度&quot;项<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--新建调度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;名称&quot;中输入调度名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--&quot;调度类型&quot;中选择你的作业执行安排<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--如果选择&quot;反复出现&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--点&quot;更改&quot;来设置你的时间安排<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">设置方法: <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">我的电脑--控制面板--管理工具--服务--右键 SQLSERVERAGENT--属性--启动类型--选择&quot;自动启动&quot;--确定. <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--3.实现同步处理的方法2,定时同步<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--在srv1中创建如下的同步处理存储过程<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">create proc p_process <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">as <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--更新修改过的数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">update b set name&#x3D;i.name,telphone&#x3D;i.telphone <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">from srv2.库名.dbo.author b,author i <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">where b.id&#x3D;i.id and<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">(b.name &lt;&gt; i.name or b.telphone &lt;&gt; i.telphone) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--插入新增的数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">insert srv2.库名.dbo.author(id,name,telphone) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select id,name,telphone from author i <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">where not exists( <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from srv2.库名.dbo.author where id&#x3D;i.id) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">--删除已经删除的数据(如果需要的话) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">delete b <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">from srv2.库名.dbo.author b <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">where not exists( <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">select * from author where id&#x3D;b.id)go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>正文结束</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>100 个网络基础知识普及，看完成半个网络高手！</title>
      <link href="/blog/2020/03/06/100-ge-wang-luo-ji-chu-zhi-shi-pu-ji-kan-wan-cheng-ban-ge-wang-luo-gao-shou/"/>
      <url>/blog/2020/03/06/100-ge-wang-luo-ji-chu-zhi-shi-pu-ji-kan-wan-cheng-ban-ge-wang-luo-gao-shou/</url>
      
        <content type="html"><![CDATA[<p>100 个网络基础知识普及，看完成半个网络高手！</p><h3 id="1）什么是链接？"><a href="#1）什么是链接？" class="headerlink" title="1）什么是链接？"></a>1）什么是链接？</h3><p>链接是指两个设备之间的连接。它包括用于一个设备能够与另一个设备通信的电缆类型和协议。</p><h3 id="2）OSI-参考模型的层次是什么？"><a href="#2）OSI-参考模型的层次是什么？" class="headerlink" title="2）OSI 参考模型的层次是什么？"></a>2）OSI 参考模型的层次是什么？</h3><p>有 7 个 OSI 层：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</p><h3 id="3）什么是骨干网？"><a href="#3）什么是骨干网？" class="headerlink" title="3）什么是骨干网？"></a>3）什么是骨干网？</h3><p>骨干网络是集中的基础设施，旨在将不同的路由和数据分发到各种网络。它还处理带宽管理和各种通道。</p><h3 id="4）什么是-LAN？"><a href="#4）什么是-LAN？" class="headerlink" title="4）什么是 LAN？"></a>4）什么是 LAN？</h3><p>LAN 是局域网的缩写。它是指计算机与位于小物理位置的其他网络设备之间的连接。</p><h3 id="5）什么是节点？"><a href="#5）什么是节点？" class="headerlink" title="5）什么是节点？"></a>5）什么是节点？</h3><p>节点是指连接发生的点。它可以是作为网络一部分的计算机或设备。为了形成网络连接，需要两个或更多个节点。</p><h3 id="6）什么是路由器？"><a href="#6）什么是路由器？" class="headerlink" title="6）什么是路由器？"></a>6）什么是路由器？</h3><p>路由器可以连接两个或更多网段。这些是在其路由表中存储信息的智能网络设备，例如路径，跳数等。有了这个信息，他们就可以确定数据传输的最佳路径。路由器在 OSI 网络层运行。</p><h3 id="7）什么是点对点链接？"><a href="#7）什么是点对点链接？" class="headerlink" title="7）什么是点对点链接？"></a>7）什么是点对点链接？</h3><p>它是指网络上两台计算机之间的直接连接。除了将电缆连接到两台计算机的 NIC卡之外，点对点连接不需要任何其他网络设备。</p><h3 id="8）什么是匿名-FTP？"><a href="#8）什么是匿名-FTP？" class="headerlink" title="8）什么是匿名 FTP？"></a>8）什么是匿名 FTP？</h3><p>匿名 FTP 是授予用户访问公共服务器中的文件的一种方式。允许访问这些服务器中的数据的用户不需要识别自己，而是以匿名访客身份登录。</p><h3 id="9）什么是子网掩码？"><a href="#9）什么是子网掩码？" class="headerlink" title="9）什么是子网掩码？"></a>9）什么是子网掩码？</h3><p>子网掩码与 IP 地址组合，以识别两个部分：扩展网络地址和主机地址。像 IP 地址一样，子网掩码由 32 位组成。</p><h3 id="10）UTP-电缆允许的最大长度是多少？"><a href="#10）UTP-电缆允许的最大长度是多少？" class="headerlink" title="10）UTP 电缆允许的最大长度是多少？"></a>10）UTP 电缆允许的最大长度是多少？</h3><p>UTP 电缆的单段具有 90 到 100 米的允许长度。这种限制可以通过使用中继器和开关来克服</p><h3 id="11）什么是数据封装？"><a href="#11）什么是数据封装？" class="headerlink" title="11）什么是数据封装？"></a>11）什么是数据封装？</h3><p>数据封装是在通过网络传输信息之前将信息分解成更小的可管理块的过程。在这个过程中，源和目标地址与奇偶校验一起附加到标题中。</p><h3 id="12）描述网络拓扑"><a href="#12）描述网络拓扑" class="headerlink" title="12）描述网络拓扑"></a>12）描述网络拓扑</h3><p>网络拓扑是指计算机网络的布局。它显示了设备和电缆的物理布局，以及它们如何连接到彼此。</p><h3 id="13）什么是-VPN？"><a href="#13）什么是-VPN？" class="headerlink" title="13）什么是 VPN？"></a>13）什么是 VPN？</h3><p>VPN 意味着虚拟专用网络，这种技术允许通过网络（如 Internet）创建安全通道。</p><p>例如，VPN 允许您建立到远程服务器的安全拨号连接。</p><h3 id="14）简要描述-NAT。"><a href="#14）简要描述-NAT。" class="headerlink" title="14）简要描述 NAT。"></a>14）简要描述 NAT。</h3><p>NAT 是网络地址转换。这是一种协议，为公共网络上的多台计算机提供一种方式来共享到 Internet 的单一连接。</p><h3 id="15）OSI-参考模型下网络层的工作是什么？"><a href="#15）OSI-参考模型下网络层的工作是什么？" class="headerlink" title="15）OSI 参考模型下网络层的工作是什么？"></a>15）OSI 参考模型下网络层的工作是什么？</h3><p>网络层负责数据路由，分组交换和网络拥塞控制。路由器在此层下运行。</p><h3 id="16）网络拓扑如何影响您在建立网络时的决策？"><a href="#16）网络拓扑如何影响您在建立网络时的决策？" class="headerlink" title="16）网络拓扑如何影响您在建立网络时的决策？"></a>16）网络拓扑如何影响您在建立网络时的决策？</h3><p>网络拓扑决定了互连设备必须使用什么媒介。它还作为适用于设置的材料，连接器和终端的基础。</p><h3 id="17）什么是-RIP？"><a href="#17）什么是-RIP？" class="headerlink" title="17）什么是 RIP？"></a>17）什么是 RIP？</h3><p>RIP，路由信息协议的简称由路由器用于将数据从一个网络发送到另一个网络。</p><p>它通过将其路由表广播到网络中的所有其他路由器来有效地管理路由数据。它以跳数为单位确定网络距离。</p><h3 id="18）什么是不同的方式来保护计算机网络？"><a href="#18）什么是不同的方式来保护计算机网络？" class="headerlink" title="18）什么是不同的方式来保护计算机网络？"></a>18）什么是不同的方式来保护计算机网络？</h3><p>有几种方法可以做到这一点。在所有计算机上安装可靠和更新的防病毒程序。确保防火墙的设置和配置正确。用户认证也将有很大的帮助。所有这些组合将构成一个高度安全的网络。</p><h3 id="19）什么是-NIC？"><a href="#19）什么是-NIC？" class="headerlink" title="19）什么是 NIC？"></a>19）什么是 NIC？</h3><p>NIC 是网络接口卡（网卡）的缩写。这是连接到 PC 以连接到网络沈北。每个 NIC都有自己的 MAC 地址，用于标识网络上的 PC。</p><h3 id="20）什么是-WAN？"><a href="#20）什么是-WAN？" class="headerlink" title="20）什么是 WAN？"></a>20）什么是 WAN？</h3><p>WAN 代表广域网。它是地理上分散的计算机和设备的互连。它连接位于不同地区和国家&#x2F;地区的网络。</p><h3 id="21）OSI-物理层的重要性是什么？"><a href="#21）OSI-物理层的重要性是什么？" class="headerlink" title="21）OSI 物理层的重要性是什么？"></a>21）OSI 物理层的重要性是什么？</h3><p>物理层进行从数据位到电信号的转换，反之亦然。这是网络设备和电缆类型的考虑和设置。</p><h3 id="22）TCP-x2F-IP-下有多少层？"><a href="#22）TCP-x2F-IP-下有多少层？" class="headerlink" title="22）TCP&#x2F;IP 下有多少层？"></a>22）TCP&#x2F;IP 下有多少层？</h3><p>有四层：网络层，互联网层，传输层和应用层。</p><h3 id="23）什么是代理服务器，它们如何保护计算机网络？"><a href="#23）什么是代理服务器，它们如何保护计算机网络？" class="headerlink" title="23）什么是代理服务器，它们如何保护计算机网络？"></a>23）什么是代理服务器，它们如何保护计算机网络？</h3><p>代理服务器主要防止外部用户识别内部网络的 IP 地址。不知道正确的 IP 地址，甚至无法识别网络的物理位置。代理服务器可以使外部用户几乎看不到网络。</p><h3 id="24）OSI-会话层的功能是什么？"><a href="#24）OSI-会话层的功能是什么？" class="headerlink" title="24）OSI 会话层的功能是什么？"></a>24）OSI 会话层的功能是什么？</h3><p>该层为网络上的两个设备提供协议和方法，通过举行会话来相互通信。这包括设置会话，管理会话期间的信息交换以及终止会话时的解除过程。</p><h3 id="25）实施容错系统的重要性是什么？有限吗？"><a href="#25）实施容错系统的重要性是什么？有限吗？" class="headerlink" title="25）实施容错系统的重要性是什么？有限吗？"></a>25）实施容错系统的重要性是什么？有限吗？</h3><p>容错系统确保持续的数据可用性。这是通过消除单点故障来实现的。但是，在某些情况下，这种类型的系统将无法保护数据，例如意外删除。</p><h3 id="26）10Base-T-是什么意思？"><a href="#26）10Base-T-是什么意思？" class="headerlink" title="26）10Base-T 是什么意思？"></a>26）10Base-T 是什么意思？</h3><p>10 是指数据传输速率，在这种情况下是 10Mbps。“Base”是指基带。T 表示双绞线，这是用于该网络的电缆。</p><h3 id="27）什么是私有-IP-地址？"><a href="#27）什么是私有-IP-地址？" class="headerlink" title="27）什么是私有 IP 地址？"></a>27）什么是私有 IP 地址？</h3><p>专用 IP 地址被分配用于内部网。这些地址用于内部网络，不能在外部公共网络上路由。这些确保内部网络之间不存在任何冲突，同时私有 IP 地址的范围同样可重复使用于多个内部网络，因为它们不会“看到”彼此。</p><h3 id="28）什么是-NOS？"><a href="#28）什么是-NOS？" class="headerlink" title="28）什么是 NOS？"></a>28）什么是 NOS？</h3><p>NOS 或网络操作系统是专门的软件，其主要任务是向计算机提供网络连接，以便能够与其他计算机和连接的设备进行通信。</p><h3 id="29）什么是-DoS？"><a href="#29）什么是-DoS？" class="headerlink" title="29）什么是 DoS？"></a>29）什么是 DoS？</h3><p>DoS 或拒绝服务攻击是试图阻止用户访问互联网或任何其他网络服务。这种攻击可能有不同的形式，由一群永久者组成。这样做的一个常见方法是使系统服务器过载，使其无法再处理合法流量，并将被强制重置。</p><h3 id="30）什么是-OSI，它在电脑网络中扮演什么角色？"><a href="#30）什么是-OSI，它在电脑网络中扮演什么角色？" class="headerlink" title="30）什么是 OSI，它在电脑网络中扮演什么角色？"></a>30）什么是 OSI，它在电脑网络中扮演什么角色？</h3><p>OSI（开放系统互连）作为数据通信的参考模型。它由 7 层组成，每层定义了网络设备如何相互连接和通信的特定方面。一层可以处理所使用的物理介质，而另一层则指示如何通过网络实际传输数据。</p><h3 id="31）电缆被屏蔽并具有双绞线的目的是什么？"><a href="#31）电缆被屏蔽并具有双绞线的目的是什么？" class="headerlink" title="31）电缆被屏蔽并具有双绞线的目的是什么？"></a>31）电缆被屏蔽并具有双绞线的目的是什么？</h3><p>其主要目的是防止串扰。串扰是电磁干扰或噪声，可能影响通过电缆传输的数据。</p><h3 id="32）地址共享的优点是什么？"><a href="#32）地址共享的优点是什么？" class="headerlink" title="32）地址共享的优点是什么？"></a>32）地址共享的优点是什么？</h3><p>通过使用地址转换而不是路由，地址共享提供了固有的安全性优势。这是因为互联网上的主机只能看到提供地址转换的计算机上的外部接口的公共 IP 地址，而不是内部网络上的私有 IP 地址。</p><h3 id="33）什么是-MAC-地址？"><a href="#33）什么是-MAC-地址？" class="headerlink" title="33）什么是 MAC 地址？"></a>33）什么是 MAC 地址？</h3><p>MAC 或媒介访问控制，可以唯一地标识网络上的设备。它也被称为物理地址或以太网地址。MAC 地址由 6 个字节组成。</p><h3 id="34）在-OSI-参考模型方面，TCP-x2F-IP-应用层的等同层或多层是什么？"><a href="#34）在-OSI-参考模型方面，TCP-x2F-IP-应用层的等同层或多层是什么？" class="headerlink" title="34）在 OSI 参考模型方面，TCP&#x2F;IP 应用层的等同层或多层是什么？"></a>34）在 OSI 参考模型方面，TCP&#x2F;IP 应用层的等同层或多层是什么？</h3><h3 id="TCP-x2F-IP-应用层实际上在-OSI-模型上具有三个对等体：会话层，表示层和应用层。"><a href="#TCP-x2F-IP-应用层实际上在-OSI-模型上具有三个对等体：会话层，表示层和应用层。" class="headerlink" title="TCP&#x2F;IP 应用层实际上在 OSI 模型上具有三个对等体：会话层，表示层和应用层。"></a>TCP&#x2F;IP 应用层实际上在 OSI 模型上具有三个对等体：会话层，表示层和应用层。</h3><h3 id="35）如何识别给定-IP-地址的-IP-类？"><a href="#35）如何识别给定-IP-地址的-IP-类？" class="headerlink" title="35）如何识别给定 IP 地址的 IP 类？"></a>35）如何识别给定 IP 地址的 IP 类？</h3><p>通过查看任何给定 IP 地址的第一个八位字节，您可以识别它是 A 类，B 类还是 C类。如果第一个八位字节以 0 位开头，则该地址为 Class A.如果以位 10 开头，则该地址为 B 类地址。如果从 110 开始，那么它是 C 类网络。</p><h3 id="36）OSPF-的主要目的是什么？"><a href="#36）OSPF-的主要目的是什么？" class="headerlink" title="36）OSPF 的主要目的是什么？"></a>36）OSPF 的主要目的是什么？</h3><p>OSPF 或开放最短路径优先，是使用路由表确定数据交换的最佳路径的链路状态路由协议。</p><h3 id="37）什么是防火墙？"><a href="#37）什么是防火墙？" class="headerlink" title="37）什么是防火墙？"></a>37）什么是防火墙？</h3><p>防火墙用于保护内部网络免受外部攻击。这些外部威胁可能是黑客谁想要窃取数据或计算机病毒，可以立即消除数据。它还可以防止来自外部网络的其他用户访问专用网络。</p><h3 id="38）描述星形拓扑"><a href="#38）描述星形拓扑" class="headerlink" title="38）描述星形拓扑"></a>38）描述星形拓扑</h3><p>星形拓扑由连接到节点的中央集线器组成。这是最简单的设置和维护之一。</p><h3 id="39）什么是网关？"><a href="#39）什么是网关？" class="headerlink" title="39）什么是网关？"></a>39）什么是网关？</h3><p>网关提供两个或多个网段之间的连接。它通常是运行网关软件并提供翻译服务的计算机。该翻译是允许不同系统在网络上通信的关键。</p><h3 id="40）星型拓扑的缺点是什么？"><a href="#40）星型拓扑的缺点是什么？" class="headerlink" title="40）星型拓扑的缺点是什么？"></a>40）星型拓扑的缺点是什么？</h3><p>星形拓扑的一个主要缺点是，一旦中央集线器或交换机被损坏，整个网络就变得不可用了。</p><h3 id="41）什么是-SLIP？"><a href="#41）什么是-SLIP？" class="headerlink" title="41）什么是 SLIP？"></a>41）什么是 SLIP？</h3><p>SLIP 或串行线路接口协议实际上是在 UNIX 早期开发的旧协议。这是用于远程访问的协议之一。</p><h3 id="42）给出一些私有网络地址的例子。"><a href="#42）给出一些私有网络地址的例子。" class="headerlink" title="42）给出一些私有网络地址的例子。"></a>42）给出一些私有网络地址的例子。</h3><p>10.0.0.0，子网掩码为 255.0.0.0</p><p>172.16.0.0，子网掩码为 255.240.0.0</p><p>千人ccie认证交流群463904693</p><p>领取最新CCIE考试题库</p><p>CCIE 认证经验分享千人群：463904693</p><p>192.168.0.0，子网掩码为 255.255.0.0</p><h3 id="43）什么是-tracert？"><a href="#43）什么是-tracert？" class="headerlink" title="43）什么是 tracert？"></a>43）什么是 tracert？</h3><p>Tracert 是一个 Windows 实用程序，可用于跟踪从路由器到目标网络的数据采集的路由。它还显示了在整个传输路由期间采用的跳数。</p><h3 id="44）网络管理员的功能是什么？"><a href="#44）网络管理员的功能是什么？" class="headerlink" title="44）网络管理员的功能是什么？"></a>44）网络管理员的功能是什么？</h3><p>网络管理员有许多责任，可以总结为 3 个关键功能：安装网络，配置网络设置以及网络的维护&#x2F;故障排除。</p><h3 id="45）描述对等网络的一个缺点。"><a href="#45）描述对等网络的一个缺点。" class="headerlink" title="45）描述对等网络的一个缺点。"></a>45）描述对等网络的一个缺点。</h3><p>当您正在访问由网络上的某个工作站共享的资源时，该工作站的性能会降低。</p><h3 id="46）什么是混合网络？"><a href="#46）什么是混合网络？" class="headerlink" title="46）什么是混合网络？"></a>46）什么是混合网络？</h3><p>混合网络是利用客户端 - 服务器和对等体系结构的网络设置。</p><h3 id="47）什么是-DHCP？"><a href="#47）什么是-DHCP？" class="headerlink" title="47）什么是 DHCP？"></a>47）什么是 DHCP？</h3><p>DHCP 是动态主机配置协议的缩写。其主要任务是自动为网络上的设备分配 IP 地址。它首先检查任何设备尚未占用的下一个可用地址，然后将其分配给网络设备。</p><h3 id="48）ARP-的主要工作是什么？"><a href="#48）ARP-的主要工作是什么？" class="headerlink" title="48）ARP 的主要工作是什么？"></a>48）ARP 的主要工作是什么？</h3><p>ARP 或地址解析协议的主要任务是将已知的 IP 地址映射到 MAC 层地址。</p><h3 id="49）什么是-TCP-x2F-IP？"><a href="#49）什么是-TCP-x2F-IP？" class="headerlink" title="49）什么是 TCP&#x2F;IP？"></a>49）什么是 TCP&#x2F;IP？</h3><p>TCP&#x2F;IP 是传输控制协议&#x2F;互联网协议的缩写。这是一组协议层，旨在在不同类型的计算机网络（也称为异构网络）上进行数据交换。</p><h3 id="50）如何使用路由器管理网络？"><a href="#50）如何使用路由器管理网络？" class="headerlink" title="50）如何使用路由器管理网络？"></a>50）如何使用路由器管理网络？</h3><p>路由器内置了控制台，可让您配置不同的设置，如安全和数据记录。您可以为计算机分配限制，例如允许访问的资源，或者可以浏览互联网的某一天的特定时间。</p><p>您甚至可以对整个网络中看不到的网站施加限制。</p><h3 id="51）当您希望在不同平台（如-UNIX-系统和-Windows-服务器之间）传输文件时，可以应用什么协议？"><a href="#51）当您希望在不同平台（如-UNIX-系统和-Windows-服务器之间）传输文件时，可以应用什么协议？" class="headerlink" title="51）当您希望在不同平台（如 UNIX 系统和 Windows 服务器之间）传输文件时，可以应用什么协议？"></a>51）当您希望在不同平台（如 UNIX 系统和 Windows 服务器之间）传输文件时，可以应用什么协议？</h3><p>使用 FTP（文件传输协议）在这些不同的服务器之间进行文件传输。这是可能的，因为 FTP 是平台无关的。</p><h3 id="52）默认网关的使用是什么？"><a href="#52）默认网关的使用是什么？" class="headerlink" title="52）默认网关的使用是什么？"></a>52）默认网关的使用是什么？</h3><p>默认网关提供了本地网络连接到外部网络的方法。用于连接外部网络的默认网关通常是外部路由器端口的地址。</p><h3 id="53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？"><a href="#53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？" class="headerlink" title="53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？"></a>53）保护网络的一种方法是使用密码。什么可以被认为是好的密码？</h3><p>良好的密码不仅由字母组成，还包括字母和数字的组合。结合大小写字母的密码比使用所有大写字母或全部小写字母的密码有利。密码必须不能被黑客很容易猜到，比如日期，姓名，收藏夹等等。</p><h3 id="54）UTP-电缆的正确终止率是多少？"><a href="#54）UTP-电缆的正确终止率是多少？" class="headerlink" title="54）UTP 电缆的正确终止率是多少？"></a>54）UTP 电缆的正确终止率是多少？</h3><p>非屏蔽双绞线网线的正常终止是 100 欧姆。</p><h3 id="55）什么是-netstat？"><a href="#55）什么是-netstat？" class="headerlink" title="55）什么是 netstat？"></a>55）什么是 netstat？</h3><p>Netstat 是一个命令行实用程序。它提供有关连接当前 TCP&#x2F;IP 设置的有用信息。</p><h3 id="56）C-类网络中的网络-ID-数量是多少？"><a href="#56）C-类网络中的网络-ID-数量是多少？" class="headerlink" title="56）C 类网络中的网络 ID 数量是多少？"></a>56）C 类网络中的网络 ID 数量是多少？</h3><p>对于 C 类网络，可用的网络 ID 位数为 21。可能的网络 ID 数目为 2，提高到 21或 2,097,152。每个网络 ID 的主机 ID 数量为 2，增加到 8 减去 2，或 254。</p><h3 id="57）使用长于规定长度的电缆时会发生什么？"><a href="#57）使用长于规定长度的电缆时会发生什么？" class="headerlink" title="57）使用长于规定长度的电缆时会发生什么？"></a>57）使用长于规定长度的电缆时会发生什么？</h3><p>电缆太长会导致信号丢失。这意味着数据传输和接收将受到影响，因为信号长度下降。</p><h3 id="58）什么常见的软件问题可能导致网络缺陷？"><a href="#58）什么常见的软件问题可能导致网络缺陷？" class="headerlink" title="58）什么常见的软件问题可能导致网络缺陷？"></a>58）什么常见的软件问题可能导致网络缺陷？</h3><p>软件相关问题可以是以下任何一种或其组合：</p><p>- 客户端服务器问题</p><p>- 应用程序冲突</p><p>- 配置错误</p><p>- 协议不匹配</p><p>- 安全问题</p><p>- 用户政策和权利问题</p><h3 id="59）什么是-ICMP？"><a href="#59）什么是-ICMP？" class="headerlink" title="59）什么是 ICMP？"></a>59）什么是 ICMP？</h3><p>ICMP 是 Internet 控制消息协议。它为 TCP&#x2F;IP 协议栈内的协议提供消息传递和通信。这也是管理由 PING 等网络工具使用的错误信息的协议。</p><h3 id="60）什么是-Ping？"><a href="#60）什么是-Ping？" class="headerlink" title="60）什么是 Ping？"></a>60）什么是 Ping？</h3><p>Ping 是一个实用程序，允许您检查网络上的网络设备之间的连接。您可以使用其IP 地址或设备名称（如计算机名称）ping 设备。</p><h3 id="61）什么是点对点（P2P）？"><a href="#61）什么是点对点（P2P）？" class="headerlink" title="61）什么是点对点（P2P）？"></a>61）什么是点对点（P2P）？</h3><p>对等是不在服务器上回复的网络。该网络上的所有 PC 都是单独的工作站。</p><h3 id="62）什么是-DNS？"><a href="#62）什么是-DNS？" class="headerlink" title="62）什么是 DNS？"></a>62）什么是 DNS？</h3><p>DNS 是域名系统。该网络服务的主要功能是为 TCP&#x2F;IP 地址解析提供主机名。</p><h3 id="63）光纤与其他介质有什么优势？"><a href="#63）光纤与其他介质有什么优势？" class="headerlink" title="63）光纤与其他介质有什么优势？"></a>63）光纤与其他介质有什么优势？</h3><p>光纤的一个主要优点是不太容易受到电气干扰。它还支持更高的带宽，意味着可以发送和接收更多的数据。长距离信号降级也非常小。</p><h3 id="64）集线器和交换机有什么区别？"><a href="#64）集线器和交换机有什么区别？" class="headerlink" title="64）集线器和交换机有什么区别？"></a>64）集线器和交换机有什么区别？</h3><p>集线器充当多端口中继器。然而，随着越来越多的设备连接到它，它将无法有效地管理通过它的流量。交换机提供了一个更好的替代方案，可以提高性能，特别是在所有端口上预期有高流量时。</p><h3 id="65）Windows-RRAS-服务支持的不同网络协议是什么？"><a href="#65）Windows-RRAS-服务支持的不同网络协议是什么？" class="headerlink" title="65）Windows RRAS 服务支持的不同网络协议是什么？"></a>65）Windows RRAS 服务支持的不同网络协议是什么？</h3><p>支持三种主要的网络协议：NetBEUI，TCP&#x2F;IP 和 IPX。</p><h3 id="66）A，B-和-C-类网络中的最大网络和主机是什么？"><a href="#66）A，B-和-C-类网络中的最大网络和主机是什么？" class="headerlink" title="66）A，B 和 C 类网络中的最大网络和主机是什么？"></a>66）A，B 和 C 类网络中的最大网络和主机是什么？</h3><p>对于 A 类，有 126 个可能的网络和 16,777,214 个主机</p><p>对于 B 类，有 16,384 个可能的网络和 65,534 个主机</p><p>对于 C 类，有 2,097,152 个可能的网络和 254 个主机</p><h3 id="67）直通电缆的标准颜色顺序是什么？"><a href="#67）直通电缆的标准颜色顺序是什么？" class="headerlink" title="67）直通电缆的标准颜色顺序是什么？"></a>67）直通电缆的标准颜色顺序是什么？</h3><p>橙色&#x2F;白色，橙色，绿色&#x2F;白色，蓝色，蓝色&#x2F;白色，绿色，棕色&#x2F;白色，棕色。</p><h3 id="68）什么协议落在-TCP-x2F-IP-协议栈的应用层之下？"><a href="#68）什么协议落在-TCP-x2F-IP-协议栈的应用层之下？" class="headerlink" title="68）什么协议落在 TCP&#x2F;IP 协议栈的应用层之下？"></a>68）什么协议落在 TCP&#x2F;IP 协议栈的应用层之下？</h3><p>以下是 TCP&#x2F;IP 应用层协议：FTP，TFTP，Telnet 和 SMTP。</p><h3 id="69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？"><a href="#69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？" class="headerlink" title="69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？"></a>69）您需要连接两台电脑进行文件共享。是否可以这样做，而不使用集线器或路由器？</h3><p>是的，您可以使用一根电缆将两台计算机连接在一起。在这种情况下可以使用交叉型电缆。在这种设置中，一条电缆的数据传输引脚连接到另一条电缆的数据接收引脚，反之亦然。</p><h3 id="70）什么是-ipconfig？"><a href="#70）什么是-ipconfig？" class="headerlink" title="70）什么是 ipconfig？"></a>70）什么是 ipconfig？</h3><p>Ipconfig 是一个常用于识别网络上计算机的地址信息的实用程序。它可以显示物理地址以及 IP 地址。</p><h3 id="71）直通和交叉电缆有什么区别？"><a href="#71）直通和交叉电缆有什么区别？" class="headerlink" title="71）直通和交叉电缆有什么区别？"></a>71）直通和交叉电缆有什么区别？</h3><p>直通电缆用于将计算机连接到交换机，集线器或路由器。交叉电缆用于将两个类似设备连接在一起，如 PC 到 PC 或集线器到集线器。</p><h3 id="72）什么是客户端-x2F-服务器？"><a href="#72）什么是客户端-x2F-服务器？" class="headerlink" title="72）什么是客户端&#x2F;服务器？"></a>72）什么是客户端&#x2F;服务器？</h3><p>客户端&#x2F;服务器是一种类型的网络，其中一个或多个计算机充当服务器。服务器提供集中的资源库，如打印机和文件。客户端是指访问服务器的工作站。</p><h3 id="73）描述网络。"><a href="#73）描述网络。" class="headerlink" title="73）描述网络。"></a>73）描述网络。</h3><p>网络是指用于数据通信的计算机和外围设备之间的互连。可以使用有线电缆或通过无线链路进行网络连接。</p><h3 id="74）将-NIC-卡从一台-PC-移动到另一台-PC-时，MAC-地址是否也被转移？"><a href="#74）将-NIC-卡从一台-PC-移动到另一台-PC-时，MAC-地址是否也被转移？" class="headerlink" title="74）将 NIC 卡从一台 PC 移动到另一台 PC 时，MAC 地址是否也被转移？"></a>74）将 NIC 卡从一台 PC 移动到另一台 PC 时，MAC 地址是否也被转移？</h3><p>是的，那是因为 MAC 地址是硬连线到 NIC 电路，而不是 PC。这也意味着当 NIC卡被另一个替换时，PC 可以具有不同的 MAC 地址。</p><h3 id="75）解释聚类支持"><a href="#75）解释聚类支持" class="headerlink" title="75）解释聚类支持"></a>75）解释聚类支持</h3><p>群集支持是指网络操作系统在容错组中连接多台服务器的能力。这样做的主要目的是在一台服务器发生故障的情况下，集群中的下一个服务器将继续进行所有处理。</p><h3 id="76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？"><a href="#76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？" class="headerlink" title="76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？"></a>76）在包含两个服务器和二十个工作站的网络中，安装防病毒程序的最佳位置是哪里？</h3><p>必须在所有服务器和工作站上安装防病毒程序，以确保保护。这是因为个人用户可以访问任何工作站，并在插入可移动硬盘驱动器或闪存驱动器时引入计算机病毒。</p><h3 id="77）描述以太网。"><a href="#77）描述以太网。" class="headerlink" title="77）描述以太网。"></a>77）描述以太网。</h3><p>以太网是当今使用的流行网络技术之一。它是在 20 世纪 70 年代初开发的，并且基于 IEEE 中规定的规范。以太网在局域网中使用。</p><h3 id="78）实现环形拓扑有什么缺点？"><a href="#78）实现环形拓扑有什么缺点？" class="headerlink" title="78）实现环形拓扑有什么缺点？"></a>78）实现环形拓扑有什么缺点？</h3><p>如果网络上的一个工作站发生故障，可能会导致整个网络丢失。另一个缺点是，当需要在网络的特定部分进行调整和重新配置时，整个网络也必须被暂时关闭。</p><h3 id="79）CSMA-x2F-CD-和-CSMA-x2F-CA-有什么区别？"><a href="#79）CSMA-x2F-CD-和-CSMA-x2F-CA-有什么区别？" class="headerlink" title="79）CSMA&#x2F;CD 和 CSMA&#x2F;CA 有什么区别？"></a>79）CSMA&#x2F;CD 和 CSMA&#x2F;CA 有什么区别？</h3><p>CSMA&#x2F;CD 或碰撞检测，每当碰撞发生时重新发送数据帧。CSMA&#x2F;CA 或碰撞避免，将首先在数据传输之前广播意图发送。</p><h3 id="80）什么是-SMTP？"><a href="#80）什么是-SMTP？" class="headerlink" title="80）什么是 SMTP？"></a>80）什么是 SMTP？</h3><h3 id="SMTP-是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在-TCP-x2F-IP-协议栈上提供必要的邮件传递服务。"><a href="#SMTP-是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在-TCP-x2F-IP-协议栈上提供必要的邮件传递服务。" class="headerlink" title="SMTP 是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在 TCP&#x2F;IP 协议栈上提供必要的邮件传递服务。"></a>SMTP 是简单邮件传输协议的缩写。该协议处理所有内部邮件，并在 TCP&#x2F;IP 协议栈上提供必要的邮件传递服务。</h3><h3 id="81）什么是组播路由？"><a href="#81）什么是组播路由？" class="headerlink" title="81）什么是组播路由？"></a>81）什么是组播路由？</h3><p>组播路由是一种有针对性的广播形式，将消息发送到所选择的用户组，而不是将其发送到子网上的所有用户。</p><h3 id="82）加密在网络上的重要性是什么？"><a href="#82）加密在网络上的重要性是什么？" class="headerlink" title="82）加密在网络上的重要性是什么？"></a>82）加密在网络上的重要性是什么？</h3><p>加密是将信息转换成用户不可读的代码的过程。然后使用秘密密钥或密码将其翻译或解密回其正常可读格式。加密有助于确保中途截获的信息仍然不可读，因为用户必须具有正确的密码或密钥。</p><h3 id="83）如何安排和显示-IP-地址？"><a href="#83）如何安排和显示-IP-地址？" class="headerlink" title="83）如何安排和显示 IP 地址？"></a>83）如何安排和显示 IP 地址？</h3><p>IP 地址显示为一系列由周期或点分隔的四位十进制数字。这种安排的另一个术语是点分十进制格式。一个例子是 192.168.101.2</p><h3 id="84）解释认证的重要性。"><a href="#84）解释认证的重要性。" class="headerlink" title="84）解释认证的重要性。"></a>84）解释认证的重要性。</h3><p>认证是在用户登录网络之前验证用户凭据的过程。它通常使用用户名和密码进行。这提供了限制来自网络上的有害入侵者的访问的安全手段。</p><h3 id="85）隧道模式是什么意思？"><a href="#85）隧道模式是什么意思？" class="headerlink" title="85）隧道模式是什么意思？"></a>85）隧道模式是什么意思？</h3><p>这是一种数据交换模式，其中两个通信计算机本身不使用 IPSec。相反，将 LAN连接到中转网络的网关创建了一个使用 IPSec 协议来保护通过它的所有通信的虚拟隧道。</p><h3 id="86）建立-WAN-链路涉及的不同技术有哪些？"><a href="#86）建立-WAN-链路涉及的不同技术有哪些？" class="headerlink" title="86）建立 WAN 链路涉及的不同技术有哪些？"></a>86）建立 WAN 链路涉及的不同技术有哪些？</h3><p>模拟连接 - 使用常规电话线；数字连接 - 使用数字电话线；交换连接 - 使用发送方和接收方之间的多组链接来移动数据。</p><h3 id="87）网格拓扑的一个优点是什么？"><a href="#87）网格拓扑的一个优点是什么？" class="headerlink" title="87）网格拓扑的一个优点是什么？"></a>87）网格拓扑的一个优点是什么？</h3><p>在一个链接失败的情况下，总会有另一个链接可用。网状拓扑实际上是最容错的网络拓扑之一。</p><h3 id="88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？"><a href="#88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？" class="headerlink" title="88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？"></a>88）在排除计算机网络问题时，可能会发生什么常见的硬件相关问题？</h3><p>大部分网络由硬件组成。这些领域的问题可能包括硬盘故障，NIC 损坏甚至硬件启动。不正确的硬件配置也是其中一个疑难问题。</p><h3 id="89）可以做什么来修复信号衰减问题？"><a href="#89）可以做什么来修复信号衰减问题？" class="headerlink" title="89）可以做什么来修复信号衰减问题？"></a>89）可以做什么来修复信号衰减问题？</h3><p>处理这种问题的常见方法是使用中继器和集线器，因为它将有助于重新生成信号，从而防止信号丢失。检查电缆是否正确终止也是必须的。</p><h3 id="90）动态主机配置协议如何协助网络管理？"><a href="#90）动态主机配置协议如何协助网络管理？" class="headerlink" title="90）动态主机配置协议如何协助网络管理？"></a>90）动态主机配置协议如何协助网络管理？</h3><p>网络管理员不必访问每台客户端计算机来配置静态 IP 地址，而是可以应用动态主机配置协议来创建称为可以动态分配给客户端的范围的 IP 地址池。</p><h3 id="91）解释网络概念的概况？"><a href="#91）解释网络概念的概况？" class="headerlink" title="91）解释网络概念的概况？"></a>91）解释网络概念的概况？</h3><p>配置文件是为每个用户设置的配置设置。例如，可以创建将用户置于组中的配置文件。</p><h3 id="92）什么是-Sneakernet？"><a href="#92）什么是-Sneakernet？" class="headerlink" title="92）什么是 Sneakernet？"></a>92）什么是 Sneakernet？</h3><p>Sneakernet 被认为是最早的联网形式，其中使用可移动介质（如磁盘，磁带）物理传输数据。</p><h3 id="93）IEEE-在计算机网络中的作用是什么？"><a href="#93）IEEE-在计算机网络中的作用是什么？" class="headerlink" title="93）IEEE 在计算机网络中的作用是什么？"></a>93）IEEE 在计算机网络中的作用是什么？</h3><p>IEEE 或电气和电子工程师学会是由电气和电子设备标准发布和管理的工程师组成的组织。这包括网络设备，网络接口，cablings 和连接器。</p><h3 id="94）TCP-x2F-IP-Internet-层下有哪些协议？"><a href="#94）TCP-x2F-IP-Internet-层下有哪些协议？" class="headerlink" title="94）TCP&#x2F;IP Internet 层下有哪些协议？"></a>94）TCP&#x2F;IP Internet 层下有哪些协议？</h3><p>该层管理的协议有 4 种。这些是 ICMP，IGMP，IP 和 ARP。</p><h3 id="95）谈到网络，什么是权限？"><a href="#95）谈到网络，什么是权限？" class="headerlink" title="95）谈到网络，什么是权限？"></a>95）谈到网络，什么是权限？</h3><p>权限是指在网络上执行特定操作的授权许可。网络上的每个用户可以分配个人权限，具体取决于该用户必须允许的内容。</p><h3 id="96）建立-VLAN-的一个基本要求是什么？"><a href="#96）建立-VLAN-的一个基本要求是什么？" class="headerlink" title="96）建立 VLAN 的一个基本要求是什么？"></a>96）建立 VLAN 的一个基本要求是什么？</h3><p>需要一个 VLAN，因为在交换机级别只有一个广播域，这意味着每当新用户连接时，该信息都会传播到整个网络。交换机上的 VLAN 有助于在交换机级别创建单独的广播域。它用于安全目的。</p><h3 id="97）什么是-IPv6？"><a href="#97）什么是-IPv6？" class="headerlink" title="97）什么是 IPv6？"></a>97）什么是 IPv6？</h3><p>IPv6 或 Internet 协议版本 6 被开发以替代 IPv4。目前，IPv4 正在用于控制互联网流量，但 IPv4 已经饱和。IPv6 能够克服这个限制。</p><h3 id="98）什么是-RSA-算法？"><a href="#98）什么是-RSA-算法？" class="headerlink" title="98）什么是 RSA 算法？"></a>98）什么是 RSA 算法？</h3><p>RSA 是 Rivest-Shamir-Adleman 算法的缩写。它是目前最常用的公钥加密算法。</p><h3 id="99）什么是网格拓扑？"><a href="#99）什么是网格拓扑？" class="headerlink" title="99）什么是网格拓扑？"></a>99）什么是网格拓扑？</h3><p>网格拓扑是一种设置，其中每个设备都直接连接到网络上的每个其他设备。因此，它要求每个设备具有至少两个网络连接。</p><h3 id="100）100Base-FX-网络的最大段长度是多少？"><a href="#100）100Base-FX-网络的最大段长度是多少？" class="headerlink" title="100）100Base-FX 网络的最大段长度是多少？"></a>100）100Base-FX 网络的最大段长度是多少？</h3><p>使用 100Base-FX 的网段的最大允许长度为 412 米。整个网络的最大长度为 5 公里。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣、好玩、又装B的 Linux 命令！</title>
      <link href="/blog/2020/02/29/you-qu-hao-wan-you-zhuang-b-de-linux-ming-ling/"/>
      <url>/blog/2020/02/29/you-qu-hao-wan-you-zhuang-b-de-linux-ming-ling/</url>
      
        <content type="html"><![CDATA[<p><font face="黑体" color=red> 1. sl 命令 </font></p><p>你会看到一辆火车从屏幕右边开往左边……</p><p>安装</p><p><code>$ sudo apt-get install sl</code></p><p>运行   </p><p><code>$sl</code></p><p>命令有 -a l F e 几个选项，</p><pre class="line-numbers language-none"><code class="language-none">-a An accident seems to happen. You&#39;ll feel pity for people who cry for help.-l shows little one.-F It flies.-e Allow interrupt by Ctrl+C.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122400.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122400.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>可以给别人来个恶作剧，他一敲ls，不知道的肯定很有效果</p><p><code>$alias ls=sl</code></p><p><font face="黑体" color=red>2.    frotune 命令 </font></p><p>输出一句话，有笑话，名言什么的 (还有唐诗宋词sudo apt-get install fortune-zh)</p><p>安装</p><p><code>$sudo apt-get install fortune</code></p><p>运行</p><p><code>$fortune</code></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122406.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122406.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red>3. cowsay 命令 </font></p><p>用ASCII字符打印牛，羊等动物，还有个cowthink，这个是奶牛想，那个是奶牛说，哈哈，差不多</p><p>安装</p><p><code>$sudo apt-get install cowsay</code></p><p>运行</p><p><code>$cowsay &quot;I am not a cow, hahaha&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/073932acb19c787be39d32e80d0ca473.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/073932acb19c787be39d32e80d0ca473.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red>4. cmatrix 命令 </font></p><p>这个很酷！《黑客帝国》那种矩阵风格的动画效果</p><p>安装</p><p><code>$ sudo apt-get install cmatrix</code></p><p>运行</p><p><code>$cmatrix</code></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122432.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122432.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red>5. figlet 、toilet命令 </font></p><p>艺术字生成器，由ASCII字符组成，把文本显示成标题栏。此外还有banner这个命令</p><p>安装</p><p><code>$sudo apt-get install figlet         $sudo apt-get install toilet       </code></p><p>运行</p><p><code>$figlet fuck you !   </code></p><p><code>$toilet i love you</code></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122445.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122445.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>toilet 还可以添加颜色，里面的选项请自己 man 一下</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122454.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306122454.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red> 13、高大上仪表盘blessed-contrib——假装自己指点江山，纵横捭阖  </font></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">sudo apt<span class="token operator">-</span>get install npmsudo apt install nodejs<span class="token operator">-</span>legacygit clone https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>yaronn<span class="token operator">/</span>blessed<span class="token operator">-</span>contrib<span class="token punctuation">.</span>gitcd blessed<span class="token operator">-</span>contribnpm installnode <span class="token punctuation">.</span>/examples<span class="token operator">/</span>dashboard<span class="token punctuation">.</span>js  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>高大上黑客仪表盘</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123651.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123651.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p> <font face="黑体" color=red>14、高大上仪表盘hollywood——假装自己日理万机，宵衣旰食 </font></p><p> Dustin Kirkland 利用一个长途飞行的时间，编写了这个炫酷、有趣但也没什么实际作用的软件。  </p><p>在其它Linux发行版中，可以通过以下命令安装并运行。  </p><pre class="line-numbers language-none"><code class="language-none">sudo apt-add-repository ppa:hollywood&#x2F;ppasudo apt-get install hollywoodsudo apt-get install byobuhollywood<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123701.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123701.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red>15、追逐鼠标的小猫oneko</font></p><p> 在桌面的命令行界面输入  </p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install onekooneko<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后输入oneko，即可看到效果。  </p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123711.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123711.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red> 16、ASCII艺术框：box命令 </font></p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install boxesecho &quot;Tongji Univerisity&quot; | boxesecho &quot;Tongji Univerisity&quot; | boxes -d dogfortune | boxes -d cat | lolcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123727.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123727.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red>17、燃起字符串大火aafire在命令行界面输入 </font></p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install libaa-binaafire<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123737.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20200306123737.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red> 19、从删库到跑路 sudo rm -rf &#x2F;*  </font></p><p>这个命令我看着都有点害怕。。。。</p><pre class="line-numbers language-none"><code class="language-none">sudo rm -rf &#x2F;*sudo：获取root管理员权限rm：remove，即删除-rf：r表示递归删除，即删除所有的子目录，f表示不需要再进行确认&#x2F;：根目录*：所有文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/640aa.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/640aa.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/263652851C74B64CD0522D8785BA9678.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/263652851C74B64CD0522D8785BA9678.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>友情提示：千万不要轻易尝试这个命令，特别是在运行有网站服务器、数据库的Linux主机上 。</p><p>if (你的操作&#x3D;删库！！){</p><p>return  “连夜跑路，站票的那种！！”</p><p>}</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/4771EE2B.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/4771EE2B.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>这些好玩的命令可以通过查 man 手册，然后在加上自己想出来的创意，改编成更多有趣的东西，哈哈，给别人捣乱也是挺好玩的……</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2</title>
      <link href="/blog/2020/02/29/suo/"/>
      <url>/blog/2020/02/29/suo/</url>
      
        <content type="html"><![CDATA[<p><font face="黑体" color=green size=5>Java锁分类</font></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 开发者工具的 11 个骚技巧</title>
      <link href="/blog/2020/02/29/chrome-kai-fa-zhe-gong-ju-de-11-ge-sao-ji-qiao/"/>
      <url>/blog/2020/02/29/chrome-kai-fa-zhe-gong-ju-de-11-ge-sao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>对于每个前端从业者来说，除了F5键之外，用的最多的另外一个键就是F12了。才知道chrome还有各种骚姿势。这个网站是：umaar.com&#x2F;dev-tips&#x2F;，本文分享一些实用且聪明的调试技巧</p><p><font face="黑体" color=red>1、曾经，在线调伪类样式困扰过你？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/640.webp" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/640.webp" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red size=5>2、源代码快速定位到某一行！ctrl + p</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/640.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/640.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><font face="黑体" color=red size=5>3、联调接口失败时，后台老哥总管你要response？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/55.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/55.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><font face="黑体" color=red size=5>4.  你还一层层展开dom？****Alt + Click</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/60.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/60.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p><font face="黑体" color=red size=5>5、是不是报错了，你才去打断点？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/61.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/61.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red size=5>6、你是不是经常想不起来，在哪绑定事件的？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/62.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/62.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red size=5>7、你是不是打断点时还要去改代码？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/63.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/63.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red size=5>8、看dom层级的最直观的方式？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/65.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/65.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red size=5>9、查一些特定的请求，过滤器用过吗？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/66.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/66.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p><font face="黑体" color=red size=5>10 、在Elements面板调整dom结构很不方便？</font></p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/67.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/67.gif" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><h3 id="多的就不列举了，可以看看开头的网站。看了有几个功能我电脑（win10）是没有的，应该跟chrome版本有关。"><a href="#多的就不列举了，可以看看开头的网站。看了有几个功能我电脑（win10）是没有的，应该跟chrome版本有关。" class="headerlink" title="多的就不列举了，可以看看开头的网站。看了有几个功能我电脑（win10）是没有的，应该跟chrome版本有关。"></a>多的就不列举了，可以看看开头的网站。看了有几个功能我电脑（win10）是没有的，应该跟chrome版本有关。</h3><p>开发者工具的功能确实挺多，多得有时根本用不上，官网教程建议每个前端人员都看看：</p><p>中文版：<a href="https://www.html.cn/doc/chrome-devtools/">https://www.html.cn/doc/chrome-devtools/</a></p>]]></content>
      
      
      <categories>
          
          <category> Chorm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker配置阿里云镜像</title>
      <link href="/blog/2020/02/24/docker-pei-zhi-a-li-yun-jing-xiang/"/>
      <url>/blog/2020/02/24/docker-pei-zhi-a-li-yun-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="Step-1：去阿里官方获取加速地址"><a href="#Step-1：去阿里官方获取加速地址" class="headerlink" title="Step 1：去阿里官方获取加速地址"></a>Step 1：去阿里官方获取加速地址</h2><p>1.登录阿里云，<a href="https://www.aliyun.com/">官方地址</a><a href="https://www.aliyun.com/">https://www.aliyun.com/</a></p><p>2.进入控制台，搜索镜像加速器</p><p><img src="https://yremp.live/wp-content/uploads/2019/11/image-33.png" class="lazyload placeholder" data-srcset="https://yremp.live/wp-content/uploads/2019/11/image-33.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg">   </p><p>点击<em>进入</em></p><p><img src="https://yremp.live/wp-content/uploads/2019/11/image-35.png" class="lazyload placeholder" data-srcset="https://yremp.live/wp-content/uploads/2019/11/image-35.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg">  </p><h2 id="Step-2-：修改配置文件"><a href="#Step-2-：修改配置文件" class="headerlink" title="Step 2 ：修改配置文件"></a>Step 2 ：修改配置文件</h2><h3 id="CentOS-6-8"><a href="#CentOS-6-8" class="headerlink" title="CentOS 6.8"></a>CentOS 6.8</h3><p>vim &#x2F;etc&#x2F;sysconfig&#x2F;docker</p><p>我的是CentOS 7.6 所以以这个为例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">### 新建 <span class="token operator">/</span>etc<span class="token operator">/</span>docker 目录mkdir <span class="token operator">-</span>p <span class="token operator">/</span>etc<span class="token operator">/</span>docker### 进入<span class="token operator">/</span>etc<span class="token operator">/</span>dockercd <span class="token operator">/</span>etc<span class="token operator">/</span>docker### 新建并编辑daemon<span class="token punctuation">.</span>jsonvim daemon<span class="token punctuation">.</span>json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把阿里官方示例代码粘进去例如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">&#123;</span>  <span class="token string">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://3lnapjsm.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Esc ，然后 Shift+; wq保存退出</p><p>Step 3 ：重启Docker</p><p>执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">sudo systemctl daemon<span class="token operator">-</span>reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再执行下面命令重启Docker即可使配置文件生效</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">sudo systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Step-4-查看是否生效"><a href="#Step-4-查看是否生效" class="headerlink" title="Step 4:查看是否生效"></a>Step 4:查看是否生效</h2><p>执行下面代码，查看Docker信息</p><pre class="line-numbers language-none"><code class="language-none">docker info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://yremp.live/wp-content/uploads/2019/11/image-36.png" class="lazyload placeholder" data-srcset="https://yremp.live/wp-content/uploads/2019/11/image-36.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"> </p><p>OK!!!!!</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java带参无返回、带参带返回值、方法的重载</title>
      <link href="/blog/2020/02/24/java-dai-can-wu-fan-hui-dai-can-dai-fan-hui-zhi-fang-fa-de-chong-zai/"/>
      <url>/blog/2020/02/24/java-dai-can-wu-fan-hui-dai-can-dai-fan-hui-zhi-fang-fa-de-chong-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="Java带参无返回、带参带返回值、方法的重载"><a href="#Java带参无返回、带参带返回值、方法的重载" class="headerlink" title="#Java带参无返回、带参带返回值、方法的重载"></a>#Java带参无返回、带参带返回值、方法的重载</h1><p>一、</p><p>有时方法的执行需要依赖于某些条件，换句话说，要想通过方法完成特定的功能，需要为其提供额外的信息才行。例如，现实生活中电饭锅可以实现“煮饭”的功能，但前提是我们必须提供食材，如果我们什么都不提供，那就真是的“巧妇难为无米之炊”了。我们可以通过在方法中加入参数列表接收外部传入的数据信息，参数可以是任意的基本类型数据或引用类型数据。</p><p>我们先来看一个带参数，但没有返回值的方法：<img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211633413aa.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211633413aa.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>上面的代码定义了一个 show 方法，带有一个参数 name ，实现输出欢迎消息。</p><p>调用带参方法与调用无参方法的语法类似，但在调用时必须传入实际的参数值</p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211707487.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211707487.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>运行结果为： 欢迎您，爱慕课！</p><p>很多时候，我们把定义方法时的参数称为形参，目的是用来定义方法需要传入的参数的个数和类型；把调用方法时的参数称为实参，是传递给方法真正被处理的值。</p><p>一定不可忽视的问题：</p><p>1、 调用带参方法时，必须保证实参的数量、类型、顺序与形参一一对应</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211728140.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211728140.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>2、 调用方法时，实参不需要指定数据类型，如 </p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/aaaa.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/aaaa.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>3、 方法的参数可以是基本数据类型，如 int、double 等，也可以是引用数据类型，如 String、数组等</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211750838.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211750838.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>4、 当方法参数有多个时，多个参数间以逗号分隔</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211809302.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211809302.jpg" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>二、</p><p>如果方法既包含参数，又带有返回值，我们称为带参带返回值的方法。</p><p>例如：下面的代码，定义了一个 show 方法，带有一个参数 name ，方法执行后返回一个 String 类型的结果</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211921434.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211921434.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>调用带参带返回值的方法：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211939617.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512211939617.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>运行结果为： 欢迎您，爱慕课！</p><p>三、</p><p>问： 什么是方法的重载呢？</p><p>答： 如果同一个类中包含了两个或两个以上方法名相同、方法参数的个数、顺序或类型不同的方法，则称为方法的重载，也可称该方法被重载了。如下所示 4 个方法名称都为 show ，但方法的参数有所不同，因此都属于方法的重载：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512212029641.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512212029641.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>问： 如何区分调用的是哪个重载方法呢？</p><p>答： 当调用被重载的方法时， Java 会根据参数的个数和类型来判断应该调用哪个重载方法，参数完全匹配的方法将被执行。如：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512212049984.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512212049984.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512212106239.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/geng-chao/PicGo/img/20180512212106239.png" srcset="https://img2.baidu.com/it/u=2037979560,2772131037&fm=26&fmt=auto&gp=0.jpg"></p><p>判断方法重载的依据：</p><p>1、 必须是在同一个类中</p><p>2、 方法名相同</p><p>3、 方法参数的个数、顺序或类型不同</p><p>4、 与方法的修饰符或返回值没有关系</p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用negix转发服务器遇到的问题</title>
      <link href="/blog/2020/02/24/shi-yong-negix-zhuan-fa-fu-wu-qi-yu-dao-de-wen-ti/"/>
      <url>/blog/2020/02/24/shi-yong-negix-zhuan-fa-fu-wu-qi-yu-dao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="解决nginx设置反向代理后，css-js-gif-jpg-jpeg-png-bmp-swf等静态资源无法加载"><a href="#解决nginx设置反向代理后，css-js-gif-jpg-jpeg-png-bmp-swf等静态资源无法加载" class="headerlink" title="解决nginx设置反向代理后，css|js|gif|jpg|jpeg|png|bmp|swf等静态资源无法加载"></a>解决nginx设置反向代理后，css|js|gif|jpg|jpeg|png|bmp|swf等静态资源无法加载</h2><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>打开浏览器开发者工具（F12），加载部署的网页内容，查看Console标签的报错信息，发现静态资源文件的加载地址存在问题，这个问题是设置反向代理后，无法获取正确的资源文件地址导致的。</p><p>&#x3D;&#x3D;解决办法&#x3D;&#x3D;：</p><p>nginx配置修改：配置静态文件的映射</p><p>server<br>    {<br>        listen 80;<br>        server_name <a href="http://www.xxx.com/">www.xxx.com</a>;   </p><pre><code>    #忽略其他配置...     location / &#123;        proxy_pass http://www.xxx.com:8012;    &#125;     #----------------| 修改静态资源代理地址 |----------------start     location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$    &#123;        proxy_pass http://www.xxx.com:8978;    &#125;     location ~ .*\.(js|css)?$    &#123;        proxy_pass http://www.xxx.com:8978;    &#125;     #----------------| 修改静态资源代理地址 |----------------end&#125;</code></pre><hr><h1 id="问题-二"><a href="#问题-二" class="headerlink" title="问题 二"></a>问题 二</h1><h3 id="服务器出现502错误-可能进程过多导致"><a href="#服务器出现502错误-可能进程过多导致" class="headerlink" title="服务器出现502错误 可能进程过多导致"></a>服务器出现502错误 可能进程过多导致</h3><p>&#x3D;&#x3D;php-fpm.conf 重要参数 max_children 和               request_terminate_timeout&#x3D;&#x3D;</p><p>php-fpm.conf有两个至关重要的参数：<br>一个是”max_children”,<br>另一个是”request_terminate_timeout”<br>我的两个设置的值一个是”40″，一个是”900″，但是这个值不是通用的，而是需要自己计算的。</p><p>计算的方式如下：<br>如果你的服务器性能足够好，且宽带资源足够充足，PHP脚本没有系循环或BUG的话你可以直接将”request_terminate_timeout”设置成0s。0s的含义是让PHP-CGI一直执行下去而没有时间限制。而如果你做不到这一点，也就是说你的PHP-CGI可能出现某个BUG，或者你的宽带不够充足或者其他的原因导致你的PHP-CGI能够假死那么就建议你给”request_terminate_timeout”赋一个值，这个值可以根据你服务器的性能进行设定。一般来说性能越好你可以设置越高，20分钟-30分钟都可以。由于我的服务器PHP脚本需要长时间运行，有的可能会超过10分钟因此我设置了900秒，这样不会导致PHP-CGI死掉而出现502 Bad gateway这个错误。</p><p>而”max_children”这个值又是怎么计算出来的呢？这个值原则上是越大越好，php-cgi的进程多了就会处理的很快，排队的请求就会很少。设置”max_children”也需要根据服务器的性能进行设定，一般来说一台服务器正常情况下每一个php-cgi所耗费的内存在20M左右，因此我的”max_children”我设置成40个，20M*40&#x3D;800M也就是说在峰值的时候所有PHP-CGI所耗内存在800M以内，低于我的有效内存1Gb。而如果我的”max_children”设置的较小，比如5-10个，那么php-cgi就会“很累”，处理速度也很慢，等待的时间也较长。如果长时间没有得到处理的请求就会出现504 Gateway Time-out这个错误，而正在处理的很累的那几个php-cgi如果遇到了问题就会出现502 Bad gateway这个错误。</p><p>max_requests即是说每个进程若超过这个数目(跟php进程有一点点关系,关系不大),就自动杀死..我这里应该设置512的,不过懒得压力测试了,设置大一点,不过也不要设置过大,是个结构体,没测试过,接近8K到9K大小.网上动辄设置100k,有点浪费内存了.一个进程浪费大小接近1M.按照网上常用配置的128个进程,大概浪费100M左右.好吧,我承认100M是白菜价,但也别这样浪费..&#x3D; &#x3D;</p><p>max_children基本就是进程数,跟nginx的进程没有想象中的那么大,因为FPM会自己管理进程(有待考证,起码我简单浏览了一下源码,认为是这个意思).参数不宜设置过大,很占内存,进程的消耗就不用我多说了.</p><p>max_children较好的设置方式根据req&#x2F;s来设置,若程序是 100 req&#x2F;s的处理能力..最大并发是10K,那么就设置 100比较好,这是动态来调整的.</p><p>不过你若用php 5.3,也可以把style设置为apache-like,那么设置start_servers,min_spare_servers,max_spare_servers三个参数就可以自动调整<br>很简单,具体看配置文件,这样的设置之后,在高负载和复杂的php程序会省事一点,毕竟测试req&#x2F;s是可恶的体力活.</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
